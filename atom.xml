<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-19T10:24:27.661Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Lambda表达式]]></title>
        <id>https://spark-wz.github.io/post/lambda-biao-da-shi</id>
        <link href="https://spark-wz.github.io/post/lambda-biao-da-shi">
        </link>
        <updated>2019-12-18T01:38:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简介</strong><br>
Lambda表达式是一个匿名函数，简单来说就是一种没有声明的方法，即没有访问修饰符，返回值声明和名称。<br>
在仅编写一次方法的地方特别有用，方法定义很短，他为我们节省了，包含类声明和编写单独方法的工作。<br>
Java中的Lambda表达式通常使用语法是(argument) -&gt; (body)</p>
<p>以下是Lambda表达式的一些实例</p>
<p>(int a, int b) -&gt; { return a + b;}<br>
() -&gt; System.out.println(&quot;Hello World&quot;);<br>
(String s) -&gt; {System.out.println(s);}<br>
() -&gt; 42<br>
() -&gt; { return 3.1415};</p>
<p>**Lambda 表达式的结构</p>
<p>Lambda 表达式可以具有零个，一个或多个参数。<br>
可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如 (int a) 与刚才相同 (a)。<br>
参数用小括号括起来，用逗号分隔。例如 (a, b) 或 (int a, int b) 或 (String a, int b, float c)。<br>
空括号用于表示一组空的参数。例如 () -&gt; 42。<br>
当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 a -&gt; return a*a。<br>
Lambda 表达式的正文可以包含零条，一条或多条语句。<br>
如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。<br>
如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。</p>
<p><strong>4.2 使用方式</strong><br>
双冒号(::)操作符是java的方法引用。当我们使用一个方法的引用时，目标引用放在冒号前，目标引用提供的方法在：：之后。即目标引用::方法。<br>
person::getAge;<br>
在person类中定义的方法getAge的引用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BIO,NIO,AIO总结]]></title>
        <id>https://spark-wz.github.io/post/bionioaio-zong-jie</id>
        <link href="https://spark-wz.github.io/post/bionioaio-zong-jie">
        </link>
        <updated>2019-12-11T08:08:47.000Z</updated>
        <content type="html"><![CDATA[<p>目录:</p>
<ol>
<li>BIO (Blocking I/O) 同步并阻塞<br>
1.1 传统 BIO<br>
1.2 伪异步 IO<br>
1.3 代码示例<br>
1.4 总结</li>
<li>NIO (New I/O)    同步非阻塞<br>
2.1 NIO 简介<br>
2.2 NIO的特性/NIO与IO区别<br>
1)Non-blocking IO（非阻塞IO）<br>
2)Buffer(缓冲区)<br>
3)Channel (通道)<br>
4)Selectors(选择器)<br>
2.3 NIO 读数据和写数据方式<br>
2.4 NIO核心组件简单介绍<br>
2.5 代码示例</li>
<li>AIO (Asynchronous I/O)   异步非阻塞</li>
</ol>
<p><strong>实例</strong><br>
<strong>1. BIO (Blocking I/O)</strong><br>
同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程中等待其完成。<br>
<strong>1.1传统BIO通信模型</strong><br>
通常用一个独立的Acceptor负责监听客户端的连接，一般会在While(true)循环服务中调用accept()方法等待接受客户端请求的连接的方式监听请求，一旦接到请求，就可以在这之上进行读写请求，此时不能再接受其他客户端连接请求。只能等待当前连接的操作完成，但是可以通过多线程来支持多个客户端的连接。</p>
<p>如果想让BIO通信模型能够同时处理多个请求，就必须使用多线程（主要原因是socket.accept(),socket.read(),socket.write()射击的三个方法都是同步阻塞的），也就是说他接到客户端连接请求之后为客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答模型</strong>，如果连接创建之后不做任何事情的话，就会造成不必要的线程开销，但是可以通过 <strong>线程池</strong> 来改善，线程池还可以让线程的创建和回收成本更低。使用了FixedThreadPool可以有效的控制线程的最大数量，保证了系统有限的资源控制，实现了N（客户端请求数量）:M（处理客户端请求的线程数量）的伪异步I/O模型。</p>
<p><strong>当客户端并发访问量增加后</strong><br>
可能会导致线程堆栈溢出，创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<p><strong>1.2 伪异步 IO</strong><br>
<strong>1.3代码示例</strong><br>
客户端</p>
<figure data-type="image" tabindex="1"><img src="https://spark-wz.github.io/post-images/1576489092714.png" alt=""></figure>
<pre><code>服务端

serverSocket.accept() 接收客户端的连接请求，返回一个套接字，如果没有连接到客户端，线程处于阻塞状态，程序无法执行下去。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://spark-wz.github.io/post-images/1576489522129.png" alt=""></figure>
<p><strong>1.4小结</strong></p>
<p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p><strong>NIO new (I/O)</strong><br>
同步非阻塞的I/O模型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合常用]]></title>
        <id>https://spark-wz.github.io/post/java</id>
        <link href="https://spark-wz.github.io/post/java">
        </link>
        <updated>2019-12-11T07:14:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>java中将数组转为list</strong><br>
String[] myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List<String> myList = Arrays.asList(myArray);<br>
但是这个方法将数组转为集合后，集合的底层还是数组<img src="https://spark-wz.github.io/post-images/1576048771521.jpg" alt=""><br>
2.传递的对象必须是基本对象，不能是包装类<br>
int[] myArray = { 1, 2, 3 };<br>
List myList = Arrays.asList(myArray);<br>
System.out.println(myList.size());//1<br>
System.out.println(myList.get(0));//数组地址值<br>
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException<br>
当传入原生数据类型是,myList.get(0)拿到的是数组本身，而不是第一个值<br>
List myList = Arrays.asList(1, 2, 3);<br>
myList.add(4);//运行时报错：UnsupportedOperationException<br>
myList.remove(1);//运行时报错：UnsupportedOperationException<br>
myList.clear();//运行时报错：UnsupportedOperationException<br>
在使用add(),remove(),clear()会报错<br>
<em>正确的最简便的方法</em><br>
String myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List list = new ArrayList&lt;&gt;(Arrays.asList(myArray));</p>
<p><strong>遍历Map</strong></p>
<p>1.通过map.keySet()</p>
<p>通过key去获取value<br>
Set<Integer> set = map.keySet();</p>
<p>for (Integer integer: set) {</p>
<p>System.out.println(integer +&quot;的对应值为:&quot; + map.get(integer));</p>
<p>}<br>
2.通过map.values遍历所有的value</p>
<p>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();<br>
map.put(1,1);<br>
map.put(2,2);<br>
map.put(3,3);<br>
Collection<Integer> values = map.values();<br>
for (Integer value : values) {<br>
System.out.println(&quot;value = &quot; + value);<br>
}<br>
3.遍历map.entrySet</p>
<p>遍历map.entrySet,可同时拿到所有的KEY和VALUE<br>
Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>
for (Map.Entry&lt;Integer, Integer&gt; entry : entries) {<br>
System.out.println(&quot;entry.getValue() = &quot; + entry.getValue());<br>
}</p>
<p>4.lambda表达式</p>
<p>map.forEach((key,value) -&gt;{<br>
System.out.println(&quot;key = &quot; + key+&quot;value = &quot;+value);<br>
});</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[铜陵项目代码学习]]></title>
        <id>https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi</id>
        <link href="https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi">
        </link>
        <updated>2019-11-11T01:53:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>ThreadLocal</strong><br>
ThreadLocal是一个线程每部的存储类，可以在既定线程内存储数据，数据存储之后，只有指定线程才会得到数据。<br>
static final ThreadLocal<T> sThreadLocal = new ThreadLocal<T>();<br>
sThreadLocal.set()<br>
sThreadLocal.get()<br>
<strong>spring动态切换多数据源解决方案</strong><br>
1.建立一个数据源的名称常量类，建立一个获得和设置上下文环境的类，主要负责改变上下文数据源的名称，两个类可以合并。<br>
<img src="https://spark-wz.github.io/post-images/1574906751791.png" alt=""><br>
2.建立动态数据源类，这个类必须继承AbstractRoutingDataSource且实现方法datermineCurrentLookupKey，该方法返回一个key，一般是Object；<br>
<img src="https://spark-wz.github.io/post-images/1574907519526.png" alt=""><br>
3.编写spring的配置多个数据源<br>
<img src="https://spark-wz.github.io/post-images/1574907652472.png" alt=""><br>
<strong>config文件</strong><br>
配置数据源<br>
配置动态数据源<br>
<img src="https://spark-wz.github.io/post-images/1574911348867.png" alt=""><br>
<strong>MyBatis 逆向工程 Generator＋Example</strong><br>
<em><strong>Generator代码生成器</strong></em><br>
1.添加依赖和配置<br>
<img src="https://spark-wz.github.io/post-images/1574912134286.png" alt=""><br>
2.在generatorConfig.xml配置数据库驱动，生成实体（模型），xml文件，dao接口的包名和位置，还有对应的数据库表和实体类。<br>
<img src="https://spark-wz.github.io/post-images/1574912327152.png" alt=""><br>
3.在maven中启动<br>
<img src="https://spark-wz.github.io/post-images/1574912374990.png" alt=""><br>
<em><strong>example用法</strong></em><br>
int deleteByPrimaryKey(Integer id) thorws SQLException    按主键删除<br>
int deleteByExample(UserExample example) thorws SQLException    按条件查询<br>
String/Integer insert(User record) thorws SQLException    插入数据（返回值为ID）<br>
User selectByPrimaryKey(Integer id) thorws SQLException    按主键查询<br>
updateByExample     更新所有字段<br>
updateByExample     根据条件更新想要更新的字段<br>
updateByPrimaryKeySelective    根据主键更新密码<br>
updateByPrimaryKey    根据主键更新除了主键之外的<br>
setOrderByClause(&quot;ID DESC&quot;)id排序 也可以传多个参数 (&quot;<code>index</code> ASC,id ASC&quot;)<br>
ListselectByExample(UserExample example) thorws SQLException    按条件查询<br>
ListselectByExampleWithBLOGs(UserExample example) thorws SQLException    按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。<br>
insert   插入数据          insertSelective      插入不为null的数据<br>
int updateByPrimaryKey(User record) thorws SQLException    按主键更新<br>
int updateByPrimaryKeySelective(User record) thorws SQLException    按主键更新值不为null的字段<br>
int updateByExample(User record, UserExample example) thorws SQLException    按条件更新<br>
int updateByExampleSelective(User record, UserExample example) thorws SQLException    按条件更新值不为null的字段<br>
setOrderByClause   排序    列名是条件<br>
example.createCriteria().andEqualTo(&quot;terminalName&quot;, &quot;计量现场服务终端&quot;);<br>
条件查询用的是属性名  终端名称是计量现场服务终端<br>
example.createCriteria().andGreaterThan(&quot;id&quot;,3); 厂商id&gt;3<br>
<img src="https://spark-wz.github.io/post-images/1573009821363.png" alt=""><br>
<strong>spring刷新数据源</strong><br>
@Scheduled注解配合@EnableScheduling使用，计划任务执行<br>
将service注入，配置数据源刷新时间，调用service中更新方法<br>
<img src="https://spark-wz.github.io/post-images/1574913872984.png" alt=""><br>
@Async 加上这个注解可以异步执行</p>
<pre><code>*lambok**
懒人神器，帮你自动生成get，set之类的方法
安装方法：idea中下载lambok
![](https://spark-wz.github.io/post-images/1573562104882.png)
常用方法：
实体类或者dto类中导入lambok
加上data注解直接修饰所有getter变量，setter所有不为final的变量[]()
![](https://spark-wz.github.io/post-images/1573562183069.png) 

快捷键：alt +7 查看类中的所有方法
controller中在参数前边加@RequestBody注解，且只能加一次，
</code></pre>
<ol>
<li>@PathVariable注解，绑定参数（映射url绑定的占位符）@PathVariable(value=&quot;id&quot;) String id  可以在url中直接写id<br>
2.@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。<img src="https://spark-wz.github.io/post-images/1575362303722.png" alt=""></li>
<li></li>
</ol>
<p>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。<br>
图片示例<br>
4.@RequestParam   常用来处理简单类型的绑定<br>
通过Request.getParameter() 获取的String可直接转换为简单类型的情况<br>
<img src="https://spark-wz.github.io/post-images/1575364405727.png" alt=""></p>
<pre><code>**Criteria用法**
Excample.or()相当于 Example.Criteria criteria = Example.createCriteria;
criteria.andTestIsNull();    -里面的参数必须为null
criteria.andTestIsNotNull();     -里面的参数必须不是null
criteria.andTestEqualTo();     String  等于  
criteria.andTestBetween();     String1,String2 在区间
criteria.andTestGreaterThan();   String  大于
criteria.andTestGreaterThanOrEqualTo();   String  大于等于
criteria.andTestIn();   String 
criteria.andTestLessThan();   String 小于
criteria.andTestLessThanOrEqualTo();   String  小于等于
criteria.andTestLike();  String
criteria.andTestNotBetween();   String 小于等于
criteria.andTestNotEqualTo();   String
criteria.andTestNotIn();   String 
criteria.andTestNotLike();  String
criteria.isValid();  return boolean   检查对象是否实例化
criteria.notify();   线程通知
criteria.wait();     线程等待
</code></pre>
<p>wait() 和 notify()必须配合synchrozied关键字使用，无论是wait()还是notify()都需要首先获取目标对象的一个监听器。<br>
wait()会释放锁，而notify()不释放锁。<br>
1线程被wait();之后释放锁然后2线程执行，2线程执行notify之后，2线程执行完程序1线程才会执行。</p>
<pre><code>**时间戳**
js获得当前时间时间戳
new Date().getTime();
new Date().valueOf();
Date.parse(new Date());
</code></pre>
<p><strong>BigDecimal使用</strong><br>
1.BigDecimal转Double<br>
Double num = 123456789.98;<br>
BigDecimal big = new BigDecimal(num + &quot;&quot;);<br>
尽量用字符串的方式初始化<br>
BigDecimal num1 = new BigDecimal(&quot;0.005&quot;);<br>
BigDecimal num2 = new BigDecimal(&quot;0.00005&quot;);<br>
加法 add()函数     减法subtract()函数<br>
乘法multiply()函数    除法divide()函数    绝对值abs()函数<br>
加法BigDecimal result = num1.add(num2);<br>
减法BigDecimal result = num1.subtract(num2);<br>
乘法BigDecimal result = num1.multiply(num2);<br>
除法BigDecimal result = num1.divide(https://spark-wz.github.io/post-images/1575971121829.png)<br>
绝对值BigDecimal result = num1.abs();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[部署命令]]></title>
        <id>https://spark-wz.github.io/post/bu-shu-ming-ling</id>
        <link href="https://spark-wz.github.io/post/bu-shu-ming-ling">
        </link>
        <updated>2019-11-09T02:51:56.000Z</updated>
        <content type="html"><![CDATA[<p>cd /data/service 进入目录<br>
mkdir tl-gasoline<br>
cd tl-gasoline<br>
上传jar包<br>
nohup java -jar tl-gasoline-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;&gt; catalina.out  2&gt;&amp;1 &amp;<br>
部署项目<br>
tail -f -n 200 catalina.out<br>
查看是否成功<br>
配置nginx<br>
<img src="https://spark-wz.github.io/post-images/1573268782670.png" alt=""><br>
service nginx restart</p>
<p>ps -ef | grep java</p>
<p>kill -9 id</p>
<p><strong>linux下安装jdk</strong><br>
1.去官网下载jdk1.8   linux版本 （电脑里面有）<br>
2.去usr中创建java目录 ，解压   tar -zxvf jdk-8u231-linux-x64.tar.gz<br>
3.编辑配置文件  使用vi命令 （vi /etc/profile）<br>
4.添加配置   输入i进入编辑模式，输入shift+Q后在输入wq保存（JAVA_HOME=/usr/java/jdk1.8.0_231<br>
CLASSPATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/lib/
PATH=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>PATH:$JAVA_HOME/bin<br>
export PATH JAVA_HOME CLASSPATH）<br>
5.执行命令，使配置文件生效（source /etc/profile）<br>
6.查看是否生效（java -version）<br>
7.效果<img src="https://spark-wz.github.io/post-images/1573628339167.png" alt=""><br>
<strong>linux下安装MySql</strong><br>
1.mysql和rpm安装包 电脑上有<br>
2./opt/installer 目录<br>
3.tar xvf mysql-8.0.15-1.el7.x86_64.rpm-bundle.tar<br>
4.rpm -ivh mysql-community-common-8.0.15-1.el7.x86_64.rpm<br>
rpm -ivh mysql-community-libs-8.0.15-1.el7.x86_64.rpm --force --nodeps<br>
rpm -ivh mysql-community-devel-8.0.15-1.el7.x86_64.rpm --force --nodeps<br>
rpm -ivh mysql-community-libs-compat-8.0.15-1.el7.x86_64.rpm --force --nodeps<br>
rpm -ivh mysql-community-client-8.0.15-1.el7.x86_64.rpm --force --nodeps<br>
rpm -ivh mysql-community-server-8.0.15-1.el7.x86_64.rpm --force --nodeps<br>
5.systemctl status mysqld<br>
<strong>本机虚拟机mysql账户密码</strong><br>
root    123qweQWE<br>
update user set authentication_string = 'Platform@123' where user = 'root';<br>
GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'%'IDENTIFIED BY '123@qweQWE' WITH GRANT OPTION;<br>
GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'%' IDENTIFIED BY '123@qweQWE' WITH GRANT OPTION;<br>
<strong>mysql安装完后设置密码，更改root权限</strong><br>
连接https://blog.csdn.net/csdnxufei/article/details/88800559<br>
rpm -ev mysql-community-client-8.0.15-1.el7.x86_64 --nodeps<br>
set password for 'root'@'192.168.1.231' = '123qweQWE';<br>
set password='123456';<br>
lR/;l25C)j&gt;4<br>
GRANT ALL PRIVILEGES ON <em>.</em> TO 'root'@'%' IDENTIFIED BY '123qweQWE'<br>
ALTER USER 'root)'@'192.168.1.231' IDENTIFIED WITH mysql_native_password BY '123456';<br>
set global validate_password.policy=LOW;<br>
set global validate_password.length=6;<br>
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123qweQWE';<br>
<strong>防火墙关闭 systemctl stop firewalld</strong><br>
<strong>nginx离线安装</strong><br>
1.下载需要的版本和rpm包（电脑里面有）<br>
安装各种需要的依赖<br>
https://www.jianshu.com/p/0c9ca8c1b49c<br>
<strong>铜陵各个数据库IP  账户 密码</strong><br>
MySql              192.168.1.231         root         123@qweQWE<br>
SqlServer汽车   192.168.1.204         sa            123456<br>
SqlServer码头   192.168.1.203<br>
SqlServer铁路    192.168.1.201<br>
E:\apache-maven-3.5.0\conf\settings.xml<br>
E:\apache-maven-3.5.0\repository<br>
管理员1  guanliyuan1<br>
2<br>
操作员1  caozuoyaun1<br>
2<br>
<strong>湖州linux账户</strong><br>
root<br>
123qwe</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态sql学习]]></title>
        <id>https://spark-wz.github.io/post/dong-tai-sql-xue-xi</id>
        <link href="https://spark-wz.github.io/post/dong-tai-sql-xue-xi">
        </link>
        <updated>2019-11-07T01:36:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是动态sql动态sql有什么作用">什么是动态Sql，动态Sql有什么作用？</h2>
<p>传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率</p>
<h3 id="动态sql标签">动态Sql标签</h3>
<p><strong>if</strong><br>
利用if实现简单的条件选择<br>
<img src="https://spark-wz.github.io/post-images/1573093765857.png" alt=""><br>
gt 对应  &gt;</p>
<p>gte 对应 &gt;=</p>
<p>lt 对应 &lt;(会报错  相关联的 &quot;test&quot; 属性值不能包含 '&lt;' 字符)</p>
<p>lte 对应  &lt;=(会报错  相关联的 &quot;test&quot; 属性值不能包含 '&lt;' 字符)<br>
<strong>choose（when，otherwise）</strong><br>
相当于java的switch语句，通常与when和otherwise搭配<br>
<img src="https://spark-wz.github.io/post-images/1573108301437.png" alt=""><br>
例子中当title和author都不为null的时候，那么就二选一（前者优先），如果都为null，那么就选择otherwise中的，如果title个author中只有一个不为null，那么就选择哪个不为null的。<br>
<strong>where</strong><br>
简化Sql语句中的where的条件判断<br>
<strong>set</strong><br>
解决动态更新问题<br>
<strong>trim</strong><br>
可以灵活的去除多余的关键字</p>
<p><img src="https://spark-wz.github.io/post-images/1573094725608.png" alt="">假如说name和gender的值都不为null的话打印的SQL为：select * from user where    name = 'xx' and gender = 'xx'<br>
在标记的地方是不存在第一个and的，在where语句中 prefix是前缀，prefixoverride=“AND | OR”去掉第一个and或者or。<br>
<img src="https://spark-wz.github.io/post-images/1573094813156.png" alt=""><br>
假如说name和gender的值都不为null的话打印的SQL为：update user set name='xx' , gender='xx'     where id='x'</p>
<p>在标记的地方不存在逗号，而且自动加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义如上：</p>
<p>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</p>
<p>suffix：后缀<br>
<strong>foreach</strong><br>
迭代一个集合，通常用于in条件</p>
<p><strong>include标签和limit用法</strong> -- 湖州<br>
<sql id = "Base_Column_List" ><br>
id, number, type, start_time, end_time, start_count, end_count, this_count, status,<br>
record_type, c_t, u_t, create_user, update_user, create_user_name, update_user_name<br>
</sql><br>
<select id = "selectLast" resultMap="BaseResultMap"><br>
select<br>
<include refid="Base_Column_List" /><br>
from cz_records<br>
where number = #{number, jdbcType=INTEFER}<br>
<if test="status != null" ><br>
and status = #{status,jdbcType=INTEGER}<br>
</if><br>
order by c_t desc limit 1<br>
</select><br>
<strong>上边的sql标签内的字段，通过绑定id 在下边的include字段中，通过refid传递过来整个sql语句相当于</strong><br>
select sql标签内的字段 from 表;<br>
<strong>limit</strong>   截取查询到的第一条;<br>
<strong>补充</strong>    在知道结果只有一条的情况下，加limit 1可以提高效率;</p>
<p><strong>MySql中的sum(if(exp1,exp2,exp3))</strong><br>
加入exp1条件成立,返回exp2,不对返回exp3<br>
sum(if(type=1,this_count,0))  将所有type字段等于1的this_count相加求和</p>
<p><strong>as起别名  test as column</strong></p>
<p><strong>MyBatis中的<![CDATA[]]]]><![CDATA[></strong><br>
如果sql中有字符被xml解析之后会被转义的话，比如，&lt; ,&lt;=,&amp; 等我们不希望被转义，就会将sql语句包在<![CDATA[  ]]]]><![CDATA[>中<br>
<strong>实例</strong><br>
<if test="param.startTime != null and param.startTime != ''" ><br>
<![CDATA[ and c_t >= #{param.startTime} ]]]]><![CDATA[><br>
</if></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis逆向工程笔记]]></title>
        <id>https://spark-wz.github.io/post/mybatis-ni-xiang-gong-cheng-bi-ji</id>
        <link href="https://spark-wz.github.io/post/mybatis-ni-xiang-gong-cheng-bi-ji">
        </link>
        <updated>2019-11-04T02:40:08.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. <generatorConfiguration> 标签</strong><br>
如果需要在业务中增加别的依赖或者驱动，使用location属性知名依赖的全路径名<br>
<classPathEntry  location="E:\apache-maven-3.5.0\repository\com\microsoft\sqlserver\sqljdbc4\4.0\sqljdbc4-4.0.jar"/></p>
<p><strong>context标签</strong> 用于生成一组对象的环境<br>
<em>可用属性</em><br>
<strong>id</strong> 必选，上下文id，用于在生成错误时候提示<br>
<strong>defaultModelType</strong>用于指定生成对象的模式<br>
<strong>targetRuntime</strong> MyBatis3用于生成基于MyBatis3以上的版本的内容<br>
<img src="https://spark-wz.github.io/post-images/1572838613004.png" alt=""><br>
<strong>数据库连接驱动类，URL，用户名，密码</strong><br>
<jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver" connectionURL="jdbc:sqlserver://39.97.227.216:1433;DatabaseName=PCS06" userId="sa" password="Geyifei212"></jdbcConnection><br>
<strong>commentGenerator标签</strong><br>
由于Generator生成的注释都是英文，而且无法理解，所以关闭注释<br>
<img src="https://spark-wz.github.io/post-images/1572920494055.png" alt=""><br>
<strong>java类型处理器 javaTypeResolver</strong><br>
java类型处理器，默认使用JavaTypeResolverDefultImpl<br>
默认会先尝试使用Integer，Long，Short来对应DECIMAL和NUMERIC数据类型<br>
其中的property name = &quot;forceBigDecimals&quot;的取值规则如下：<br>
true：使用BigDecimal对应的DECIMAL个NUMERIC数据类型<br>
false：默认值<br>
scale&gt;0,length&gt;18:使用BigDeciamal<br>
scale=0,length[10,18]使用long<br>
scale=0,length[5,9]使用integer<br>
scale=0,length 小于5 使用short<br>
<strong>javaModelGenerator标签  java模型创建器</strong><br>
targetPackage：生成实体模型的包名和位置<br>
targetPackage：目标项目指定路径<br>
<em><strong>图示</strong></em><br>
<img src="https://spark-wz.github.io/post-images/1572840104537.png" alt=""><br>
标签内属性图示<br>
<img src="https://spark-wz.github.io/post-images/1572840360075.png" alt=""><br>
<strong>sqlMapGenerator 生成xml文件的包名</strong><br>
<strong>javaClientGenerator 生成dao接口的包名和位置</strong><br>
<strong>table标签  要生成的表</strong><br>
table是数据库中的表名或者视图名<br>
domainObjectName是实体类名<br>
<img src="https://spark-wz.github.io/post-images/1572840632594.png" alt=""></p>
<pre><code>--------------------------------------------------------------------------------
**Spring配置文件**
dev(开发环境)
![](https://spark-wz.github.io/post-images/1572851359555.png)
test(测试环境)
prod(生产环境) 可以设置不同的端口，对应不同的开发环境


**hikari连接池 （号称性能最好）**
minimum-idle：池中维护的最小空闲连接数。
auto-commit：自动提交从池中返回的链接。
idleTimeout： 允许在池中闲置的最长时间。
pool-name：连接池的自定义名称。
max-lifetime：池中链接最长生命周期。
</code></pre>
<p>**	pagehelper分页配置**<br>
配置数据库方言<br>
helperDialect：mysql<br>
配置分页的合理化数据<br>
reasonable：true<br>
自动分页配置<br>
supportMethodsArguments：true<br>
配置参数映射，从对象中根据属性名取值<br>
params：count=countSql</p>
<pre><code>**具体使用Excample**  java中的静态方法可以直接用列名点方法名调用
普通方法需要先new；
countByExcample：按照条件删除
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web service学习]]></title>
        <id>https://spark-wz.github.io/post/web-service-xue-xi</id>
        <link href="https://spark-wz.github.io/post/web-service-xue-xi">
        </link>
        <updated>2019-10-15T06:40:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="web-service简介">Web service简介</h4>
<p>Web service是一个平台独立的，低耦合的，自包含的，基于可编程的web的应用程序，可使用开放的XML标准来描述，发布，发现，协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>Web service技术，可以使得运行在不同机器上的不同应用无需借助附加的，专门的第三方软件或者平台或者硬件，就可以相互交换数据或集成。Web service很容易部署。</p>
<h4 id="web-service-三要素">Web service 三要素</h4>
<p>UDDI：是基于Web的，分布式的，为Web service提供的，信息注册中心的实施规范。<br>
WSDL：是用机器能阅读的方式提供一个正式描述文档而基于XML的语言，用于描述Web service及其函数，参数，返回值。简单来说就是使用规则，方便人和机器进行阅读。<br>
SOAP协议：基于HTTP，基于XML用于交换XML编码信息的轻量级协议。简单来说，就是传输协议，方便进行运输。</p>
<h4 id="web-service与socket两种通信方式的区别">Web service与Socket两种通信方式的区别</h4>
<p>1.Socket是基于TCP/IP的传输层协议，<br>
Web service是基于HTTP协议传输数据，http是基于tcp的应用层协议<br>
Web service使用了基于http的soap协议传输数据<br>
2.Socket接口通过流传输，不支持面向对象。<br>
Web service支持面向对象，最终Web service讲对象序列化后进行流传输。<br>
Web service通过soap协议进行通信，不需专门针对数据流的发送和接收进行处理，是一种跨平台的面向对象远程调用技术。<br>
3.Socket适用于高性能大数据的传输，传输的数据需要手动处理，socket通信的接口协议需要自定义。</p>
<h4 id="web-service程序">Web service程序</h4>
<p>1.建立java项目,至少有一个方法是公共的，因为是提供给别人各自使用的。<br>
记得加  <strong>@WebService注解</strong></p>
<ol>
<li>定义自己服务器发布的地址<br>
String address = &quot;http://localhost:9090/MyFirstWebService&quot;; //这个9090端口随便定义，只要不冲突即可</li>
<li>通过Endpoint的publish方法进行发布<br>
Endpoint.publish(address, new MyFirstWebService());</li>
</ol>
<pre><code>@WebService
public class MyFirstWebService {
	/**
	 * 定义webservice服务器中的方法
	 * @param content
	 * @return
	 */
	public String testWebService(String content){
		System.out.println(&quot;我收到了你发的信息：&quot; + content);
		return &quot;服务器：我转发信息给你&quot;;
	}
	
	public static void main(String[] args){
		//定义自己的webservice服务器发布的地址
		String address = &quot;http://localhost:9090/MyFirstWebService&quot;; //这个9090端口随便定义，只要不冲突即可
		//通过该方法进行发布
		Endpoint.publish(address, new MyFirstWebService());
		//打印一句话，表示一下服务器进行了开启
		System.out.println(&quot;my webservcie starting&quot;);
	}
	``` 

	




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令]]></title>
        <id>https://spark-wz.github.io/post/duan-kou-hao</id>
        <link href="https://spark-wz.github.io/post/duan-kou-hao">
        </link>
        <updated>2019-10-11T06:52:07.000Z</updated>
        <content type="html"><![CDATA[<p>26.151.48.150<br>
<strong>数据库密码</strong><br>
Geyifei212<br>
<strong>阿里云账号</strong><br>
root   Iot-platform<br>
<strong>阿里云MySql账户密码</strong><br>
root   Platform@123<br>
<strong>新疆油田账号</strong><br>
admin    123456<br>
<strong>数据采集与监控系统</strong><br>
admin   geyifei212<br>
<strong>收油软件密码</strong><br>
0001<br>
**DBmanager **<br>
技术支持   41684<br>
<strong>停止容器</strong><br>
docker-compose stop<br>
、<strong>加载镜像</strong><br>
docker load &lt;modbus.gz<br>
<strong>启动容器</strong><br>
docker-compose up -d<br>
<strong>删除应用</strong><br>
docker-compose rm<br>
<strong>重启应用</strong><br>
docker-compose restart<br>
<strong>列出compose的所有容器</strong><br>
docker-compose ps<br>
<strong>停止并删除某个compose应用</strong><br>
docker-compose down<br>
<strong>打开文件</strong><br>
vi命令，：wq保存退出<br>
<strong>查看版本</strong><br>
docker images<br>
<strong>关掉所有的进程</strong><br>
docker ps -a | awk '{print $1}' | xargs docker stop<br>
docker ps -a | awk '{if (NR&gt;1){print $1}}' | xargs docker rm<br>
<strong>加载文件</strong><br>
docker load &lt; modbus.gz<br>
<strong>要点</strong><br>
文件名一致，不能带后缀<br>
<strong>关闭防火墙</strong><br>
systemctl stop firewalld.service<br>
<strong>新阿里云远程连接密码</strong><br>
442492<br>
<strong>账号密码</strong><br>
wangzhanunicorn<br>
geyifei212<br>
mvn install:install-file -Dfile=modbus4j-2.0.7.jar -DgroupId=com.wz -DartifactId=modbus4j -Dversion=2.0.7 -Dpackaging=jar<br>
<strong>ip</strong><br>
118.31.70.142<br>
<strong>连接阿里云账号密码</strong><br>
Administrator<br>
Iot-platform</p>
<pre><code>	阿里云linux账号
	root
	123qweQWE
	
	湖州信息
	linux账户   root   123qwe
	泵房数据处理单元 ip地址192.168.1.102
	中继罐数据处理单元 ip地址192.168.1.104
	山顶数据处理单元 ip地址192.168.1.106
	机房电脑IP地址 192.168.1.10
	机房服务器192.168.1.111
	系统账户密码  admin   admin123456
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java基础面试整理]]></title>
        <id>https://spark-wz.github.io/post/java-ji-chu-mian-shi-zheng-li</id>
        <link href="https://spark-wz.github.io/post/java-ji-chu-mian-shi-zheng-li">
        </link>
        <updated>2019-10-05T02:23:16.000Z</updated>
        <content type="html"><![CDATA[<p>java的内存空间分为四类：栈(stack)、堆(heap)、代码(code)、静态数据(data)<br>
<strong>java堆栈</strong></p>
<ul>
<li>java中内存分为两种，堆内存，栈内存</li>
<li><strong>堆</strong></li>
<li>堆内存的话，主要用来存放数组和对象，可以当成管道，先进先出。</li>
<li>可以动态的分配内存大小，存取速度较慢</li>
<li>由java的自动垃圾回收器来管理</li>
<li><strong>栈</strong></li>
<li>栈主要是执行程序用的。比如：基本类型的变量和对象的引用变量。</li>
<li>存取速度比堆快，仅次于寄存器，栈数据可以共享，缺点存在栈中的数据大小和生存期是确定的。</li>
<li>栈内存可以看成一级缓存，由垃圾回收器自动回收</li>
<li><strong>堆栈区别</strong></li>
<li>1.堆内存用来存放由new创建的对象和数组。<br>
2.栈内存用来存放方法或者局部变量等<br>
3.堆是先进先出，后进后出<br>
4.栈是后进先出，先进后出<br>
<strong>java垃圾回收</strong><br>
System.gc()用于调用垃圾收集器</li>
<li>对象是否会被回收的两个经典算法：引用计数法，和可达性分析算法</li>
<li><strong>在确定了哪些对象可以被回收之后，jvm会在什么时候进行回收</strong></li>
<li>1会在cpu空闲的时候自动进行回收<br>
　2在堆内存存储满了之后<br>
　3主动调用System.gc()后尝试进行回收<br>
<strong>如何回收</strong><br>
算法又有四个：标记-清除算法,复制算法,标记-整理算法,分代收集算法.<br>
<strong>java抽象类</strong><br>
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li>
</ul>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>
<strong>java接口</strong><br>
接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。<br>
<strong>抽象类和接口的区别</strong></p>
<ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>
注：JDK 1.8 以后，接口里可以有静态方法和方法体了。<br>
<img src="https://spark-wz.github.io/post-images/1570245575166.png" alt=""><br>
<strong>“==”和equals的区别</strong><br>
*equals 方法（是String类从它的超类Object中继承的）被用来检测两个对象是否相等，即两个对象的内容是否相等。<br>
<em>==用于比较引用和比较基本数据类型时具有不同的功能：<br>
比较基本数据类型，如果两个值相同，则结果为true<br>
而在比较引用时，如果引用指向内存中的同一对象，结果为true</em><br>
<strong>java命名规范</strong><br>
1、 项目名全部小写</li>
</ol>
<p>2、 包名全部小写</p>
<p>3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。</p>
<p>如：public class MyFirstClass{}</p>
<p>4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。</p>
<p>如：int index=0;</p>
<p>public void toString(){}</p>
<p>5、 常量名全部大写</p>
<p>如：public static final String GAME_COLOR=”RED”;</p>
<p>6、所有命名规则必须遵循以下规则：</p>
<p>1)、名称只能由字母、数字、下划线、$符号组成</p>
<p>2)、不能以数字开头</p>
<p>3)、名称不能使用JAVA中的关键字。</p>
<p>4)、坚决不允许出现中文及拼音命名</p>
]]></content>
    </entry>
</feed>