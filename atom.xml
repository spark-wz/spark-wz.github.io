<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2020-05-18T04:16:53.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[定时任务@Scheduled]]></title>
        <id>https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled/</id>
        <link href="https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled/">
        </link>
        <updated>2020-05-18T01:26:17.000Z</updated>
        <content type="html"><![CDATA[<p>字段 允许值 允许的特殊字符<br>
秒 0-59 , - * /<br>
分 0-59 , - * /<br>
小时 0-23 , - * /<br>
日期 1-31 , - * ? / L W C<br>
月份 1-12 或者 JAN-DEC , - * /<br>
星期 1-7 或者 SUN-SAT , - * ? / L C #<br>
年（可选） 留空, 1970-2099 , - * /<br>
表达式意义<br>
&quot;0 0 12 * * ?&quot; 每天中午12点触发<br>
&quot;0 15 10 ? * *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ?&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发<br>
&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发<br>
&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发<br>
&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>
&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发<br>
&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发<br>
&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发<br>
&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发<br>
&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发<br>
&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发<br>
每天早上6点<br>
0 6 * * *<br>
每两个小时<br>
0 */2 * * *<br>
晚上11点到早上8点之间每两个小时，早上八点<br>
0 23-7/2，8 * * *<br>
每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点<br>
0 11 4 * 1-3<br>
1月1日早上4点<br>
0 4 1 1 *</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[taos数据库]]></title>
        <id>https://spark-wz.github.io/post/taos-shu-ju-ku/</id>
        <link href="https://spark-wz.github.io/post/taos-shu-ju-ku/">
        </link>
        <updated>2020-05-12T06:38:25.000Z</updated>
        <content type="html"><![CDATA[<p>TDengine要求每个数据点单独建表，系统中表的数量和采集点点的数量在一个量级.<br>
超级表(STable)是同一类型数据采集点的抽象，是同类型采集实例的集合，包含多张数据结构一样的子表。<br>
TDengine使用标准SQL语法定义表，使用关键词tags指定标签信息<br>
create table &lt;stable_name&gt;(&lt;field_name&gt; timestamp,field_name1 field_type,……) tags(tag_name tag_type,…)</p>
<p>实例<br>
create table thermometer (ts timestamp, degree float)<br>
tags (location binary(20),type int);</p>
<p>沿用例子，使用超级表建立单个温度计数据表</p>
<p>create table t1 using thermometer tags('beijing',10);</p>
<p>tags字段的名称和类型：</p>
<p>1.tags总长度不能超过512bytes。<br>
2.tags列的数据类型不能是timestamp。<br>
3.tags列名不能与其他列名相同。<br>
4.tags列名不能为预留关键字。</p>
<p>删除STable时，所有通过该STable时，所有通过该超级表建立的表都会被删除。</p>
<p>查看属于某STable并满足查询条件的表<br>
SELECT TBNAME,[TAG_NAME,…] FROM &lt;stable_name&gt; WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)</p>
<p>查询过程中可以加条件计数啥的</p>
<p>#写数据时自动建子表</p>
<p>自动建表只能建立子表不能建立超级表<br>
INSERT INTO &lt;tb_name&gt; USING &lt;stb_name&gt; TAGS (&lt;tag1_value&gt;, ...) VALUES (field_value, ...) (field_value, ...) ...;</p>
<p>#STable中tag管理</p>
<p>添加新标签<br>
alter table &lt;stable_name&gt; add tag&lt;new_tag_name&gt; <type><br>
删除标签<br>
drop tag<br>
修改 change<br>
修改子表标签值<br>
alter table &lt;table_name&gt; set tag &lt;tag_name&gt;=&lt;new_tag_value&gt;</p>
<p>#STable多表聚合</p>
<p>针对超级表子表进行多表聚合查询，支持按照全部的tag值进行条件过滤，不支持binary类型的模糊查询</p>
<p>SELECT function&lt;field_name&gt;,…<br>
FROM &lt;stable_name&gt;<br>
WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)<br>
INTERVAL (<time range>)<br>
GROUP BY &lt;tag_name&gt;, &lt;tag_name&gt;…<br>
ORDER BY &lt;tag_name&gt; &lt;asc|desc&gt;<br>
SLIMIT &lt;group_limit&gt;<br>
SOFFSET &lt;group_offset&gt;<br>
LIMIT &lt;record_limit&gt;<br>
OFFSET &lt;record_offset&gt;<br>
超级表聚合查询，TDengine目前支持sum、count、avg、first、last、min、max、top、bottom不使用orderBy的查询将会对超级表下满足条件的进行查询</p>
<p>#STable使用实例</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序]]></title>
        <id>https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/</id>
        <link href="https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/">
        </link>
        <updated>2020-04-02T09:47:30.000Z</updated>
        <content type="html"><![CDATA[<p>第一步：前端调用wx.login()函数，获取返回的code值。（每次通过wx.login()得到的code值可能不一样）</p>
<p>第二步：传递获取到的code值到服务器端，在服务器端用小程序appid，appsecret等去请求微信服务器，获取openid和session_key。（注：每个微信账号，在每个小程序中获取到的openid是唯一的，它可以作为判断新用户和老用户的依据。）</p>
<p>第三步：将用户openid保存到数据库，并将用户id返回到前端，放到缓存中保持登录态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python BeautifulSoup]]></title>
        <id>https://spark-wz.github.io/post/python-beautifulsoup/</id>
        <link href="https://spark-wz.github.io/post/python-beautifulsoup/">
        </link>
        <updated>2020-04-01T08:42:35.000Z</updated>
        <content type="html"><![CDATA[<p>BeautifulSoup是一个可以从html或者xml中提取数据的Python库。<br>
BeautifulSoup最常用解析器（lxml）效率最高<br>
soup = BeautifulSoup(rurl,'lxml')</p>
<p><strong>根据name属性找<br>
soup.name<br>
soup.head 只获取head标签<br>
soup.body.b 获取第一个b标签<br>
通过点取属性的方式只能获得当前名字的第一个tag标签<br>
获取所有的a标签soup.find_all()<br>
soup.find_all('a')</strong></p>
<p><strong>tag的.contains属性可以将tag的子节点以列表的方式输出<br>
字符创没有.contains属性，因为没有子节点。<br>
tag的.children可以对tag的直接子节点循环<br>
for child in title_tag.children:<br>
print(child)<br>
.descendants可以对tag的所有子孙节点进行递归循环<br>
for child in head_tag.descendants:<br>
print(child)</strong></p>
<pre><code>**.parent 可以拿到父节点
html的父节点是BeautifulSoup
.parents可以递归循环所有的父类节点
link = soup.a
</code></pre>
<p>link</p>
<h1 id="a-classsister-hrefhttpexamplecomelsie-idlink1elsiea"><a class="sister" href="http://example.com/elsie" id="link1">Elsie</a></h1>
<p>for parent in link.parents:<br>
if parent is None:<br>
print(parent)<br>
else:<br>
print(parent.name)<br>
**</p>
<p><strong>兄弟节点</strong><br>
sibling_soup.prettify())输出所有兄弟节点<br>
sibling_soup.b.next_sibling 输出后边的兄弟节点</p>
<h1 id="ctext2c"><c>text2</c></h1>
<p>sibling_soup.c.previous_sibling输出前边的兄弟节点</p>
<h1 id="btext1b"><b>text1</b></h1>
<p><strong>正则表达式</strong><br>
re<br>
import re<br>
complie()返回匹配的对象，单独使用没有意义，和find_all搭配使用</p>
<p><strong>true</strong><br>
for tag in soup.find_all(True):<br>
print(tag.name)</p>
<h1 id="html">html</h1>
<h1 id="head">head</h1>
<h1 id="title">title</h1>
<h1 id="body">body</h1>
<h1 id="p">p</h1>
<h1 id="b">b</h1>
<h1 id="p-2">p</h1>
<h1 id="a">a</h1>
<h1 id="a-2">a</h1>
<h1 id="a-3">a</h1>
<h1 id="p-可以匹配任何值但是不会返回字符串节点">p 可以匹配任何值，但是不会返回字符串节点。</h1>
<p><strong>id</strong><br>
soup.find_all(id='link2')<br>
根据id匹配</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL规范]]></title>
        <id>https://spark-wz.github.io/post/mysql-gui-fan/</id>
        <link href="https://spark-wz.github.io/post/mysql-gui-fan/">
        </link>
        <updated>2020-01-06T06:56:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>数据类型</strong><br>
MySQL中小数的数据类型有float（前7）和double（前15），都是浮点类型数都只有前几位准确，不精确，decimal是精确的小数，通常用于货币，计算精确的数。<br>
varchar类型的，如果长度不超过255都用char</p>
<p><strong>基本字段</strong><br>
一般表的基本字段，id、is_deleted(假删除)、c_t、u_t、create_user、update_user、create_user_name、update_user_name</p>
<p><strong>注意事项</strong><br>
记得写注释<br>
记得加默认值，数字的就是0<br>
字符串的就 EMPTY STRING<br>
<img src="https://spark-wz.github.io/post-images/1578298913491.png" alt="" loading="lazy"><br>
如果字符串时null的话，去查的话就很废效率。</p>
<p>前端传给我取钥匙或者存钥匙<br>
把所有状态为空的钥匙柜放在实时页面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[钥匙柜]]></title>
        <id>https://spark-wz.github.io/post/yao-chi-ju/</id>
        <link href="https://spark-wz.github.io/post/yao-chi-ju/">
        </link>
        <updated>2019-12-30T06:25:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>整体流程</strong><br>
从钥匙柜sqlserver数据库里面取数存到mysql中,再从sqlserver中读数给前端。<br>
两张表一张实时表,一张历史表<br>
<strong>要点</strong></p>
<ul>
<li>实时数据<br>
切换到MySQL,从MySQL中读数返给前端,根据时间排序。写一个同步方法，先切换到MySQL中,删除MySQL实时表中的数据,再切换到sqlserver，读取sqlserver中的数据,再切换到MySQL,插入   显示当前所有钥匙状态。<br>
历史数据<br>
同步方法中，切换到MySQL,根据时间排序查到最后一个更新的id,切换到SqlServer,按条件查询，将id大于MySQL最后一个id的记录查出(条件查询)，再切换到MySQL，查到的集合插入。</li>
</ul>
<p>写一个根据前端参数返回数据的方法，返回给前端。<br>
<strong>sqlServer的generator配置</strong><br>
<jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver" connectionURL="jdbc:sqlserver://HQR333TW24G54FN\ADMIN; DatabaseName=I-KeyBox" userId="sa" password="123456"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\ggdon\sqljdbc4-4.0.jar"/><br>
<strong>MySQL的generator配置</strong><br>
<jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://39.97.227.216:3306/gasoline?useUnicode=true&amp;characterEncoding=utf8" userId="root" password="Platform@123"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\apache-maven-3.5.0\repository\mysql\mysql-connector-java\5.1.6\mysql-connector-java-5.1.6.jar"/></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录一次本地jar包导入maven仓库踩到的坑]]></title>
        <id>https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/</id>
        <link href="https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/">
        </link>
        <updated>2019-12-20T02:27:13.000Z</updated>
        <content type="html"><![CDATA[<p>首先将conf/repository中的setttings中的配置文件路径改成自己的路径，要不会报一个路径不对的错，如下<br>
<img src="https://spark-wz.github.io/post-images/1576809073329.png" alt="" loading="lazy"><br>
改成自己的路径之后使用mvn命令直接将jar包导入自己的maven仓库，设置好依赖的3个属性。<br>
将jar包放到lib目录下<br>
mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.7.jar -DgroupId=com.wz.package -DartifactId=modbus4j -Dversion=2.0.7 -Dpackaging=jar<br>
其中Dfile是当前目录加jar包全称，DgroupId 可以随便起，DartifactId一般是jar包名,Dversion是版本号。</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/serotonin-timer-2.0.6.jar -DgroupId=com.wz.package -DartifactId=serotonin-timer -Dversion=2.0.6 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/commons-logging-1.2.jar -DgroupId=com.wz.package -DartifactId=commons-logging -Dversion=1.2 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/sqljdbc4-3.0.jar -DgroupId=com.wz.package -DartifactId=sqljdbc4 -Dversion=3.0 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.2.jar -DgroupId=com.wz.package -DartifactId=modbus4j2 -Dversion=2.0.2 -Dpackaging=jar</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式]]></title>
        <id>https://spark-wz.github.io/post/lambda-biao-da-shi/</id>
        <link href="https://spark-wz.github.io/post/lambda-biao-da-shi/">
        </link>
        <updated>2019-12-18T01:38:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简介</strong><br>
Lambda表达式是一个匿名函数，简单来说就是一种没有声明的方法，即没有访问修饰符，返回值声明和名称。<br>
在仅编写一次方法的地方特别有用，方法定义很短，他为我们节省了，包含类声明和编写单独方法的工作。<br>
Java中的Lambda表达式通常使用语法是(argument) -&gt; (body)</p>
<p>以下是Lambda表达式的一些实例</p>
<p>(int a, int b) -&gt; { return a + b;}<br>
() -&gt; System.out.println(&quot;Hello World&quot;);<br>
(String s) -&gt; {System.out.println(s);}<br>
() -&gt; 42<br>
() -&gt; { return 3.1415};</p>
<p>**Lambda 表达式的结构</p>
<p>Lambda 表达式可以具有零个，一个或多个参数。<br>
可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如 (int a) 与刚才相同 (a)。<br>
参数用小括号括起来，用逗号分隔。例如 (a, b) 或 (int a, int b) 或 (String a, int b, float c)。<br>
空括号用于表示一组空的参数。例如 () -&gt; 42。<br>
当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 a -&gt; return a*a。<br>
Lambda 表达式的正文可以包含零条，一条或多条语句。<br>
如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。<br>
如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。</p>
<p><strong>4.2 使用方式</strong><br>
双冒号(::)操作符是java的方法引用。当我们使用一个方法的引用时，目标引用放在冒号前，目标引用提供的方法在：：之后。即目标引用::方法。<br>
person::getAge;<br>
在person类中定义的方法getAge的引用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合常用]]></title>
        <id>https://spark-wz.github.io/post/java/</id>
        <link href="https://spark-wz.github.io/post/java/">
        </link>
        <updated>2019-12-11T07:14:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>java中将数组转为list</strong><br>
String[] myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List<String> myList = Arrays.asList(myArray);<br>
但是这个方法将数组转为集合后，集合的底层还是数组<img src="https://spark-wz.github.io/post-images/1576048771521.jpg" alt="" loading="lazy"><br>
2.传递的对象必须是基本对象，不能是包装类<br>
int[] myArray = { 1, 2, 3 };<br>
List myList = Arrays.asList(myArray);<br>
System.out.println(myList.size());//1<br>
System.out.println(myList.get(0));//数组地址值<br>
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException<br>
当传入原生数据类型是,myList.get(0)拿到的是数组本身，而不是第一个值<br>
List myList = Arrays.asList(1, 2, 3);<br>
myList.add(4);//运行时报错：UnsupportedOperationException<br>
myList.remove(1);//运行时报错：UnsupportedOperationException<br>
myList.clear();//运行时报错：UnsupportedOperationException<br>
在使用add(),remove(),clear()会报错<br>
<em>正确的最简便的方法</em><br>
String myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List list = new ArrayList&lt;&gt;(Arrays.asList(myArray));</p>
<p><strong>遍历Map</strong></p>
<p>1.通过map.keySet()</p>
<p>通过key去获取value<br>
Set<Integer> set = map.keySet();</p>
<p>for (Integer integer: set) {</p>
<p>System.out.println(integer +&quot;的对应值为:&quot; + map.get(integer));</p>
<p>}<br>
2.通过map.values遍历所有的value</p>
<p>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();<br>
map.put(1,1);<br>
map.put(2,2);<br>
map.put(3,3);<br>
Collection<Integer> values = map.values();<br>
for (Integer value : values) {<br>
System.out.println(&quot;value = &quot; + value);<br>
}<br>
3.遍历map.entrySet</p>
<p>遍历map.entrySet,可同时拿到所有的KEY和VALUE<br>
Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>
for (Map.Entry&lt;Integer, Integer&gt; entry : entries) {<br>
System.out.println(&quot;entry.getValue() = &quot; + entry.getValue());<br>
}</p>
<p>4.lambda表达式</p>
<p>map.forEach((key,value) -&gt;{<br>
System.out.println(&quot;key = &quot; + key+&quot;value = &quot;+value);<br>
});</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[铜陵项目代码学习]]></title>
        <id>https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi/</id>
        <link href="https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi/">
        </link>
        <updated>2019-11-11T01:53:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>ThreadLocal</strong><br>
ThreadLocal是一个线程每部的存储类，可以在既定线程内存储数据，数据存储之后，只有指定线程才会得到数据。<br>
static final ThreadLocal<T> sThreadLocal = new ThreadLocal<T>();<br>
sThreadLocal.set()<br>
sThreadLocal.get()<br>
<strong>spring动态切换多数据源解决方案</strong><br>
1.建立一个数据源的名称常量类，建立一个获得和设置上下文环境的类，主要负责改变上下文数据源的名称，两个类可以合并。<br>
<img src="https://spark-wz.github.io/post-images/1574906751791.png" alt="" loading="lazy"><br>
2.建立动态数据源类，这个类必须继承AbstractRoutingDataSource且实现方法datermineCurrentLookupKey，该方法返回一个key，一般是Object；<br>
<img src="https://spark-wz.github.io/post-images/1574907519526.png" alt="" loading="lazy"><br>
3.编写spring的配置多个数据源<br>
<img src="https://spark-wz.github.io/post-images/1574907652472.png" alt="" loading="lazy"><br>
<strong>config文件</strong><br>
配置数据源<br>
配置动态数据源<br>
<img src="https://spark-wz.github.io/post-images/1574911348867.png" alt="" loading="lazy"><br>
<strong>MyBatis 逆向工程 Generator＋Example</strong><br>
<em><strong>Generator代码生成器</strong></em><br>
1.添加依赖和配置<br>
<img src="https://spark-wz.github.io/post-images/1574912134286.png" alt="" loading="lazy"><br>
2.在generatorConfig.xml配置数据库驱动，生成实体（模型），xml文件，dao接口的包名和位置，还有对应的数据库表和实体类。<br>
<img src="https://spark-wz.github.io/post-images/1574912327152.png" alt="" loading="lazy"><br>
3.在maven中启动<br>
<img src="https://spark-wz.github.io/post-images/1574912374990.png" alt="" loading="lazy"><br>
<em><strong>example用法</strong></em><br>
int deleteByPrimaryKey(Integer id) thorws SQLException    按主键删除<br>
int deleteByExample(UserExample example) thorws SQLException    按条件查询<br>
String/Integer insert(User record) thorws SQLException    插入数据（返回值为ID）<br>
User selectByPrimaryKey(Integer id) thorws SQLException    按主键查询<br>
updateByExample     更新所有字段<br>
updateByExample     根据条件更新想要更新的字段<br>
updateByPrimaryKeySelective    根据主键更新密码<br>
updateByPrimaryKey    根据主键更新除了主键之外的<br>
setOrderByClause(&quot;ID DESC&quot;)id排序 也可以传多个参数 (&quot;<code>index</code> ASC,id ASC&quot;)<br>
ListselectByExample(UserExample example) thorws SQLException    按条件查询<br>
ListselectByExampleWithBLOGs(UserExample example) thorws SQLException    按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。<br>
insert   插入数据          insertSelective      插入不为null的数据<br>
int updateByPrimaryKey(User record) thorws SQLException    按主键更新<br>
int updateByPrimaryKeySelective(User record) thorws SQLException    按主键更新值不为null的字段<br>
int updateByExample(User record, UserExample example) thorws SQLException    按条件更新<br>
int updateByExampleSelective(User record, UserExample example) thorws SQLException    按条件更新值不为null的字段<br>
setOrderByClause   排序    列名是条件<br>
example.createCriteria().andEqualTo(&quot;terminalName&quot;, &quot;计量现场服务终端&quot;);<br>
条件查询用的是属性名  终端名称是计量现场服务终端<br>
example.createCriteria().andGreaterThan(&quot;id&quot;,3); 厂商id&gt;3<br>
<img src="https://spark-wz.github.io/post-images/1573009821363.png" alt="" loading="lazy"><br>
<strong>spring刷新数据源</strong><br>
@Scheduled注解配合@EnableScheduling使用，计划任务执行<br>
将service注入，配置数据源刷新时间，调用service中更新方法<br>
<img src="https://spark-wz.github.io/post-images/1574913872984.png" alt="" loading="lazy"><br>
@Async 加上这个注解可以异步执行</p>
<pre><code>*lambok**
懒人神器，帮你自动生成get，set之类的方法
安装方法：idea中下载lambok
![](https://spark-wz.github.io/post-images/1573562104882.png)
常用方法：
实体类或者dto类中导入lambok
加上data注解直接修饰所有getter变量，setter所有不为final的变量[]()
![](https://spark-wz.github.io/post-images/1573562183069.png) 

快捷键：alt +7 查看类中的所有方法
controller中在参数前边加@RequestBody注解，且只能加一次，
</code></pre>
<ol>
<li>@PathVariable注解，绑定参数（映射url绑定的占位符）@PathVariable(value=&quot;id&quot;) String id  可以在url中直接写id<br>
2.@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。<img src="https://spark-wz.github.io/post-images/1575362303722.png" alt="" loading="lazy"></li>
<li></li>
</ol>
<p>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。<br>
图片示例<br>
4.@RequestParam   常用来处理简单类型的绑定<br>
通过Request.getParameter() 获取的String可直接转换为简单类型的情况<br>
<img src="https://spark-wz.github.io/post-images/1575364405727.png" alt="" loading="lazy"></p>
<pre><code>**Criteria用法**
Excample.or()相当于 Example.Criteria criteria = Example.createCriteria;
criteria.andTestIsNull();    -里面的参数必须为null
criteria.andTestIsNotNull();     -里面的参数必须不是null
criteria.andTestEqualTo();     String  等于  
criteria.andTestBetween();     String1,String2 在区间
criteria.andTestGreaterThan();   String  大于
criteria.andTestGreaterThanOrEqualTo();   String  大于等于
criteria.andTestIn();   String 
criteria.andTestLessThan();   String 小于
criteria.andTestLessThanOrEqualTo();   String  小于等于
criteria.andTestLike();  String
criteria.andTestNotBetween();   String 小于等于
criteria.andTestNotEqualTo();   String
criteria.andTestNotIn();   String 
criteria.andTestNotLike();  String
criteria.isValid();  return boolean   检查对象是否实例化
criteria.notify();   线程通知
criteria.wait();     线程等待
</code></pre>
<p>wait() 和 notify()必须配合synchrozied关键字使用，无论是wait()还是notify()都需要首先获取目标对象的一个监听器。<br>
wait()会释放锁，而notify()不释放锁。<br>
1线程被wait();之后释放锁然后2线程执行，2线程执行notify之后，2线程执行完程序1线程才会执行。</p>
<pre><code>**时间戳**
js获得当前时间时间戳
new Date().getTime();
new Date().valueOf();
Date.parse(new Date());
</code></pre>
<p><strong>BigDecimal使用</strong><br>
1.BigDecimal转Double<br>
Double num = 123456789.98;<br>
BigDecimal big = new BigDecimal(num + &quot;&quot;);<br>
尽量用字符串的方式初始化<br>
BigDecimal num1 = new BigDecimal(&quot;0.005&quot;);<br>
BigDecimal num2 = new BigDecimal(&quot;0.00005&quot;);<br>
加法 add()函数     减法subtract()函数<br>
乘法multiply()函数    除法divide()函数    绝对值abs()函数<br>
加法BigDecimal result = num1.add(num2);<br>
减法BigDecimal result = num1.subtract(num2);<br>
乘法BigDecimal result = num1.multiply(num2);<br>
除法BigDecimal result = num1.divide(https://spark-wz.github.io/post-images/1575971121829.png)<br>
绝对值BigDecimal result = num1.abs();</p>
]]></content>
    </entry>
</feed>