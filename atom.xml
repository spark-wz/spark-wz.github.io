<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2019-11-12T03:47:28.067Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[铜陵项目代码学习]]></title>
        <id>https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi</id>
        <link href="https://spark-wz.github.io/post/tong-ling-xiang-mu-dai-ma-xue-xi">
        </link>
        <updated>2019-11-11T01:53:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>ThreadLocal</strong><br>
ThreadLocal是一个线程每部的存储类，可以在既定线程内存储数据，数据存储之后，只有指定线程才会得到数据。<br>
static final ThreadLocal<T> sThreadLocal = new ThreadLocal<T>();<br>
sThreadLocal.set()<br>
sThreadLocal.get()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[部署命令]]></title>
        <id>https://spark-wz.github.io/post/bu-shu-ming-ling</id>
        <link href="https://spark-wz.github.io/post/bu-shu-ming-ling">
        </link>
        <updated>2019-11-09T02:51:56.000Z</updated>
        <content type="html"><![CDATA[<p>cd /data/service 进入目录<br>
mkdir tl-gasoline<br>
cd tl-gasoline<br>
上传jar包<br>
nohup java -jar tl-gasoline-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;&gt; catalina.out  2&gt;&amp;1 &amp;<br>
部署项目<br>
tail -f -n 200 catalina.out<br>
查看是否成功<br>
配置nginx<br>
<img src="https://spark-wz.github.io/post-images/1573268782670.png" alt=""><br>
service nginx restart</p>
<p>ps -ef | grep java</p>
<p>kill -9 id</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态sql学习]]></title>
        <id>https://spark-wz.github.io/post/dong-tai-sql-xue-xi</id>
        <link href="https://spark-wz.github.io/post/dong-tai-sql-xue-xi">
        </link>
        <updated>2019-11-07T01:36:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是动态sql动态sql有什么作用">什么是动态Sql，动态Sql有什么作用？</h2>
<p>传统的使用JDBC的方法，相信大家在组合复杂的的SQL语句的时候，需要去拼接，稍不注意哪怕少了个空格，都会导致错误。Mybatis的动态SQL功能正是为了解决这种问题， 其通过 if, choose, when, otherwise, trim, where, set, foreach标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率</p>
<h3 id="动态sql标签">动态Sql标签</h3>
<p><strong>if</strong><br>
利用if实现简单的条件选择<br>
<img src="https://spark-wz.github.io/post-images/1573093765857.png" alt=""><br>
<strong>choose（when，otherwise）</strong><br>
相当于java的switch语句，通常与when和otherwise搭配<br>
<img src="https://spark-wz.github.io/post-images/1573108301437.png" alt=""><br>
例子中当title和author都不为null的时候，那么就二选一（前者优先），如果都为null，那么就选择otherwise中的，如果title个author中只有一个不为null，那么就选择哪个不为null的。<br>
<strong>where</strong><br>
简化Sql语句中的where的条件判断<br>
<strong>set</strong><br>
解决动态更新问题<br>
<strong>trim</strong><br>
可以灵活的去除多余的关键字</p>
<p><img src="https://spark-wz.github.io/post-images/1573094725608.png" alt="">假如说name和gender的值都不为null的话打印的SQL为：select * from user where    name = 'xx' and gender = 'xx'<br>
在标记的地方是不存在第一个and的，在where语句中 prefix是前缀，prefixoverride=“AND | OR”去掉第一个and或者or。<br>
<img src="https://spark-wz.github.io/post-images/1573094813156.png" alt=""><br>
假如说name和gender的值都不为null的话打印的SQL为：update user set name='xx' , gender='xx'     where id='x'</p>
<p>在标记的地方不存在逗号，而且自动加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义如上：</p>
<p>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</p>
<p>suffix：后缀<br>
<strong>foreach</strong><br>
迭代一个集合，通常用于in条件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis的Example用法]]></title>
        <id>https://spark-wz.github.io/post/mybatis-de-example-yong-fa</id>
        <link href="https://spark-wz.github.io/post/mybatis-de-example-yong-fa">
        </link>
        <updated>2019-11-05T09:13:36.000Z</updated>
        <content type="html"><![CDATA[<p><strong>方法功能说明</strong><br>
int countByExample(UserExample example) thorws SQLException    按条件计数<br>
int deleteByPrimaryKey(Integer id) thorws SQLException    按主键删除<br>
int deleteByExample(UserExample example) thorws SQLException    按条件查询<br>
String/Integer insert(User record) thorws SQLException    插入数据（返回值为ID）<br>
User selectByPrimaryKey(Integer id) thorws SQLException    按主键查询<br>
ListselectByExample(UserExample example) thorws SQLException    按条件查询<br>
ListselectByExampleWithBLOGs(UserExample example) thorws SQLException    按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。<br>
int updateByPrimaryKey(User record) thorws SQLException    按主键更新<br>
int updateByPrimaryKeySelective(User record) thorws SQLException    按主键更新值不为null的字段<br>
int updateByExample(User record, UserExample example) thorws SQLException    按条件更新<br>
int updateByExampleSelective(User record, UserExample example) thorws SQLException    按条件更新值不为null的字段<br>
<img src="https://spark-wz.github.io/post-images/1573009821363.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生疏名词]]></title>
        <id>https://spark-wz.github.io/post/sheng-shu-ming-ci</id>
        <link href="https://spark-wz.github.io/post/sheng-shu-ming-ci">
        </link>
        <updated>2019-11-04T03:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>DECIMAL 十进制的，小数的<br>
NUMERIC数据类型使用标准、可变长度的内部格式来存储数字</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis逆向工程笔记]]></title>
        <id>https://spark-wz.github.io/post/mybatis-ni-xiang-gong-cheng-bi-ji</id>
        <link href="https://spark-wz.github.io/post/mybatis-ni-xiang-gong-cheng-bi-ji">
        </link>
        <updated>2019-11-04T02:40:08.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. <generatorConfiguration> 标签</strong><br>
如果需要在业务中增加别的依赖或者驱动，使用location属性知名依赖的全路径名<br>
<classPathEntry  location="E:\apache-maven-3.5.0\repository\com\microsoft\sqlserver\sqljdbc4\4.0\sqljdbc4-4.0.jar"/></p>
<p><strong>context标签</strong> 用于生成一组对象的环境<br>
<em>可用属性</em><br>
<strong>id</strong> 必选，上下文id，用于在生成错误时候提示<br>
<strong>defaultModelType</strong>用于指定生成对象的模式<br>
<strong>targetRuntime</strong> MyBatis3用于生成基于MyBatis3以上的版本的内容<br>
<img src="https://spark-wz.github.io/post-images/1572838613004.png" alt=""><br>
<strong>数据库连接驱动类，URL，用户名，密码</strong><br>
<jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver" connectionURL="jdbc:sqlserver://39.97.227.216:1433;DatabaseName=PCS06" userId="sa" password="Geyifei212"></jdbcConnection><br>
<strong>commentGenerator标签</strong><br>
由于Generator生成的注释都是英文，而且无法理解，所以关闭注释<br>
<img src="https://spark-wz.github.io/post-images/1572920494055.png" alt=""><br>
<strong>java类型处理器 javaTypeResolver</strong><br>
java类型处理器，默认使用JavaTypeResolverDefultImpl<br>
默认会先尝试使用Integer，Long，Short来对应DECIMAL和NUMERIC数据类型<br>
其中的property name = &quot;forceBigDecimals&quot;的取值规则如下：<br>
true：使用BigDecimal对应的DECIMAL个NUMERIC数据类型<br>
false：默认值<br>
scale&gt;0,length&gt;18:使用BigDeciamal<br>
scale=0,length[10,18]使用long<br>
scale=0,length[5,9]使用integer<br>
scale=0,length 小于5 使用short<br>
<strong>javaModelGenerator标签  java模型创建器</strong><br>
targetPackage：生成实体模型的包名和位置<br>
targetPackage：目标项目指定路径<br>
<em><strong>图示</strong></em><br>
<img src="https://spark-wz.github.io/post-images/1572840104537.png" alt=""><br>
标签内属性图示<br>
<img src="https://spark-wz.github.io/post-images/1572840360075.png" alt=""><br>
<strong>sqlMapGenerator 生成xml文件的包名</strong><br>
<strong>javaClientGenerator 生成dao接口的包名和位置</strong><br>
<strong>table标签  要生成的表</strong><br>
table是数据库中的表名或者视图名<br>
domainObjectName是实体类名<br>
<img src="https://spark-wz.github.io/post-images/1572840632594.png" alt=""></p>
<pre><code>--------------------------------------------------------------------------------
**Spring配置文件**
dev(开发环境)
![](https://spark-wz.github.io/post-images/1572851359555.png)
test(测试环境)
prod(生产环境) 可以设置不同的端口，对应不同的开发环境


**hikari连接池 （号称性能最好）**
minimum-idle：池中维护的最小空闲连接数。
auto-commit：自动提交从池中返回的链接。
idleTimeout： 允许在池中闲置的最长时间。
pool-name：连接池的自定义名称。
max-lifetime：池中链接最长生命周期。
</code></pre>
<p>**	pagehelper分页配置**<br>
配置数据库方言<br>
helperDialect：mysql<br>
配置分页的合理化数据<br>
reasonable：true<br>
自动分页配置<br>
supportMethodsArguments：true<br>
配置参数映射，从对象中根据属性名取值<br>
params：count=countSql</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[铜陵]]></title>
        <id>https://spark-wz.github.io/post/tong-ling</id>
        <link href="https://spark-wz.github.io/post/tong-ling">
        </link>
        <updated>2019-10-18T00:55:08.000Z</updated>
        <content type="html"><![CDATA[<p><strong>立罐</strong><br>
4001 --- 4003  0#军用轻柴油<br>
4004--4005  -10#军用柴油<br>
4006--4007   93#车用汽油</p>
<p><strong>三维力控密码41684</strong><br>
<strong>要求</strong><br>
立罐，卧罐，铁路     精简版<br>
历史数据<br>
集成铁路<br>
铁路收发油 分开 负数发油 单独数据<br>
加背景图 加链接<br>
集成功能 铁路，公路，水路，安防</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web service学习]]></title>
        <id>https://spark-wz.github.io/post/web-service-xue-xi</id>
        <link href="https://spark-wz.github.io/post/web-service-xue-xi">
        </link>
        <updated>2019-10-15T06:40:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="web-service简介">Web service简介</h4>
<p>Web service是一个平台独立的，低耦合的，自包含的，基于可编程的web的应用程序，可使用开放的XML标准来描述，发布，发现，协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>Web service技术，可以使得运行在不同机器上的不同应用无需借助附加的，专门的第三方软件或者平台或者硬件，就可以相互交换数据或集成。Web service很容易部署。</p>
<h4 id="web-service-三要素">Web service 三要素</h4>
<p>UDDI：是基于Web的，分布式的，为Web service提供的，信息注册中心的实施规范。<br>
WSDL：是用机器能阅读的方式提供一个正式描述文档而基于XML的语言，用于描述Web service及其函数，参数，返回值。简单来说就是使用规则，方便人和机器进行阅读。<br>
SOAP协议：基于HTTP，基于XML用于交换XML编码信息的轻量级协议。简单来说，就是传输协议，方便进行运输。</p>
<h4 id="web-service与socket两种通信方式的区别">Web service与Socket两种通信方式的区别</h4>
<p>1.Socket是基于TCP/IP的传输层协议，<br>
Web service是基于HTTP协议传输数据，http是基于tcp的应用层协议<br>
Web service使用了基于http的soap协议传输数据<br>
2.Socket接口通过流传输，不支持面向对象。<br>
Web service支持面向对象，最终Web service讲对象序列化后进行流传输。<br>
Web service通过soap协议进行通信，不需专门针对数据流的发送和接收进行处理，是一种跨平台的面向对象远程调用技术。<br>
3.Socket适用于高性能大数据的传输，传输的数据需要手动处理，socket通信的接口协议需要自定义。</p>
<h4 id="web-service程序">Web service程序</h4>
<p>1.建立java项目,至少有一个方法是公共的，因为是提供给别人各自使用的。<br>
记得加  <strong>@WebService注解</strong></p>
<ol>
<li>定义自己服务器发布的地址<br>
String address = &quot;http://localhost:9090/MyFirstWebService&quot;; //这个9090端口随便定义，只要不冲突即可</li>
<li>通过Endpoint的publish方法进行发布<br>
Endpoint.publish(address, new MyFirstWebService());</li>
</ol>
<pre><code>@WebService
public class MyFirstWebService {
	/**
	 * 定义webservice服务器中的方法
	 * @param content
	 * @return
	 */
	public String testWebService(String content){
		System.out.println(&quot;我收到了你发的信息：&quot; + content);
		return &quot;服务器：我转发信息给你&quot;;
	}
	
	public static void main(String[] args){
		//定义自己的webservice服务器发布的地址
		String address = &quot;http://localhost:9090/MyFirstWebService&quot;; //这个9090端口随便定义，只要不冲突即可
		//通过该方法进行发布
		Endpoint.publish(address, new MyFirstWebService());
		//打印一句话，表示一下服务器进行了开启
		System.out.println(&quot;my webservcie starting&quot;);
	}
	``` 

	




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令]]></title>
        <id>https://spark-wz.github.io/post/duan-kou-hao</id>
        <link href="https://spark-wz.github.io/post/duan-kou-hao">
        </link>
        <updated>2019-10-11T06:52:07.000Z</updated>
        <content type="html"><![CDATA[<p>26.151.48.150<br>
<strong>数据库密码</strong><br>
Geyifei212<br>
<strong>阿里云账号</strong><br>
root   Iot-platform<br>
<strong>新疆油田账号</strong><br>
admin    123456<br>
<strong>数据采集与监控系统</strong><br>
admin   geyifei212<br>
<strong>收油软件密码</strong><br>
0001<br>
**DBmanager **<br>
技术支持   41684<br>
<strong>停止容器</strong><br>
docker-compose stop<br>
、<strong>加载镜像</strong><br>
docker load &lt;modbus.gz<br>
<strong>启动容器</strong><br>
docker-compose up -d<br>
<strong>删除应用</strong><br>
docker-compose rm<br>
<strong>重启应用</strong><br>
docker-compose restart<br>
<strong>列出compose的所有容器</strong><br>
docker-compose ps<br>
<strong>停止并删除某个compose应用</strong><br>
docker-compose down<br>
<strong>打开文件</strong><br>
vi命令，：wq保存退出<br>
<strong>查看版本</strong><br>
docker images<br>
<strong>关掉所有的进程</strong><br>
docker ps -a | awk '{print $1}' | xargs docker stop<br>
docker ps -a | awk '{if (NR&gt;1){print $1}}' | xargs docker rm<br>
<strong>加载文件</strong><br>
docker load &lt; modbus.gz<br>
<strong>要点</strong><br>
文件名一致，不能带后缀<br>
<strong>关闭防火墙</strong><br>
systemctl stop firewalld.service<br>
<strong>新阿里云远程连接密码</strong><br>
442492<br>
<strong>账号密码</strong><br>
wangzhanunicorn<br>
geyifei212<br>
<strong>ip</strong><br>
118.31.70.142<br>
<strong>连接阿里云账号密码</strong><br>
Administrator<br>
Iot-platform</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实习日常整理]]></title>
        <id>https://spark-wz.github.io/post/shi-xi-ri-chang-zheng-li</id>
        <link href="https://spark-wz.github.io/post/shi-xi-ri-chang-zheng-li">
        </link>
        <updated>2019-10-10T03:54:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>lora</strong><br>
低功耗局域网无线标准（远距离无线电）。<br>
<strong>什么是opc</strong><br>
OPC是工业控制和生产自动化领域中使用的硬件和软件的接口标准，（通俗来说就是解决硬件之间的联系，有效的在应用和过程控制设备之间读写数据。<br>
O代表OLE(对象链接和嵌入)，P (process过程)，C (control控制)<br>
OPC标准采用C/S模式，OPC服务器负责向OPC客户端不断的提供数据。</p>
<p>OPC服务器包括3类对象(Object)：服务器对象(Server)、组对象(Group)和项对象(Item)<br>
<strong>consul</strong><br>
服务发现 Consul的客户端可用提供一个服务,比如 api 或者mysql ,另外一些客户端可用使用Consul去发现一个指定服务的提供者.通过DNS或者HTTP应用程序可用很容易的找到他所依赖的服务.<br>
健康检查 Consul客户端可用提供任意数量的健康检查,指定一个服务(比如:webserver是否返回了200 OK 状态码)或者使用本地节点(比如:内存使用是否大于90%). 这个信息可由operator用来监视集群的健康.被服务发现组件用来避免将流量发送到不健康的主机.<br>
Key/Value存储 应用程序可用根据自己的需要使用Consul的层级的Key/Value存储.比如动态配置,功能标记,协调,领袖选举等等,简单的HTTP API让他更易于使用.<br>
多数据中心 Consul支持开箱即用的多数据中心.这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域.<br>
Consul面向DevOps和应用开发者友好.是他适合现代的弹性的基础设施.<br>
<strong>TLS</strong><br>
TLS是安全传输层协议，用于在两个通信层之间提供保密性和数据完整性。<br>
<strong>gateWay</strong><br>
服务发现 Consul的客户端可用提供一个服务,比如 api 或者mysql ,另外一些客户端可用使用Consul去发现一个指定服务的提供者.通过DNS或者HTTP应用程序可用很容易的找到他所依赖的服务.<br>
健康检查 Consul客户端可用提供任意数量的健康检查,指定一个服务(比如:webserver是否返回了200 OK 状态码)或者使用本地节点(比如:内存使用是否大于90%). 这个信息可由operator用来监视集群的健康.被服务发现组件用来避免将流量发送到不健康的主机.<br>
Key/Value存储 应用程序可用根据自己的需要使用Consul的层级的Key/Value存储.比如动态配置,功能标记,协调,领袖选举等等,简单的HTTP API让他更易于使用.<br>
多数据中心 Consul支持开箱即用的多数据中心.这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域.<br>
Consul面向DevOps和应用开发者友好.是他适合现代的弹性的基础设施.<br>
<strong>mqtt</strong><br>
MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
]]></content>
    </entry>
</feed>