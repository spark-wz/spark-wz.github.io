<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2020-06-23T09:06:20.695Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Modbus RTU]]></title>
        <id>https://spark-wz.github.io/post/ce-shi/</id>
        <link href="https://spark-wz.github.io/post/ce-shi/">
        </link>
        <updated>2020-06-08T01:33:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows">Windows</h3>
<h4 id="依赖">依赖</h4>
<ol>
<li>Windows中需要的依赖 modbus4J-1.0.jar（modbus4j，用户modbus协议工具类，导入maven仓库）、RXTXcomm.jar（版本为2.1.7，需要和java环境中的dll文件相对应）、seroUtils-3.0.jar，目录都在/resources/libs中</li>
<li>需要的dll文件为rxtxParallel.dll、rxtxSerial.dll 版本都是2.1.7 。 存放位置在jre/bin目录下: D:\Program Files\java\jre\bin<br>
####实现</li>
<li>创建SerialParameters实例<br>
SerialParameters serialParameters = new SerialParameters();</li>
<li>设定从站地址（slaveId）、串行口波特率、设定串行口名称（区分大小写）、设定无奇偶校验、设定数据位、设定停止位、设定从站名称，<br>
<img src="https://spark-wz.github.io/post-images/1592897149873.png" alt="" loading="lazy"></li>
<li>创建ModbusFactory工厂实例，将SerialParameters作为参数创建ModbusMaster实例。<br>
<img src="https://spark-wz.github.io/post-images/1592897345686.png" alt="" loading="lazy"></li>
<li>初始化<br>
<img src="https://spark-wz.github.io/post-images/1592897399514.png" alt="" loading="lazy"></li>
<li>读取串口数据</li>
<li>创建读取请求，设定从站id、开始位、读取位数</li>
<li>主站发送请求，获取结果</li>
<li>异常判断，转换结果格式<br>
<img src="https://spark-wz.github.io/post-images/1592897782379.png" alt="" loading="lazy"></li>
</ol>
<h3 id="树莓派">树莓派</h3>
<h4 id="环境-当前重启丢失java环境删除部分文件">环境   (当前重启丢失java环境，删除部分文件)</h4>
<ol>
<li>烧写树莓派系统，测试树莓派功能。切换root用户，sudo su root 设定密码</li>
<li>jdk环境<br>
树莓派为arm32位系统，安装arm32位jdk，本地jdk包在D:\chrome\Downloads下，安装目录为/usr/local 将jdk-8u251-linux-arm32-vfp-hflt.tar.gz解压在当前目录。编辑vi /etc/profile在文件最下边加入配置<br>
export JAVA_HOME=/usr/local/jdk1.8.0_251<br>
export PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>i</mi><mi>n</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/bin:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>PATH<br>
export CLASSPATH=.:JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar<br>
刷新配置文件source /etc/profile</li>
<li>配置modbus RXTX环境（等同于rxtxParallel.dll、rxtxSerial.dll配置，需要版本都为2.1.7）</li>
<li>切换目录 cd /tmp</li>
<li>下载wget http://rxtx.qbang.org/pub/rxtx/rxtx-2.1-7r2.zip ，解压到当前目录</li>
<li>使用uname-r 命令查看当前系统版本信息，当前树莓派系统版本为4.14.90-v7+；编辑 vi /usr/include/linux/version.h文件，在文件最后一行加入 （#define UTS_RELEASE &quot;4.14.90-v7+&quot;）</li>
<li>由于RXTX没有为arm32位系统的版本，所以需要自己编译，打开刚才解压的目录 编辑configure，在文档里面找到所有的1.2*|1.3*|1.4*|1.5*，都替换为1.2*|1.3*|1.4*|1.5*|1.6*|1.7*|1.8*，更改过的configure在D:\tools\grIdea\images目录下。完成后开始编译、安装 ./configure   make   make install</li>
<li>由于编译过的RXTX只支持ttyS开头的串口，所以要做串口映射（ ln -s /dev/ttyUSB2 /dev/ttyS145），将/dev/ttyUSB2串口映射为ttyS145,在代码中读取ttyS145串口。</li>
<li>在代码中串口名参数不能直接为ttyS145，应为(/dev/ttyS145)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时任务@Scheduled]]></title>
        <id>https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled/</id>
        <link href="https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled/">
        </link>
        <updated>2020-05-18T01:26:17.000Z</updated>
        <content type="html"><![CDATA[<p>字段 允许值 允许的特殊字符<br>
秒 0-59 , - * /<br>
分 0-59 , - * /<br>
小时 0-23 , - * /<br>
日期 1-31 , - * ? / L W C<br>
月份 1-12 或者 JAN-DEC , - * /<br>
星期 1-7 或者 SUN-SAT , - * ? / L C #<br>
年（可选） 留空, 1970-2099 , - * /<br>
表达式意义<br>
&quot;0 0 12 * * ?&quot; 每天中午12点触发<br>
&quot;0 15 10 ? * *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ?&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发<br>
&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发<br>
&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发<br>
&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>
&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发<br>
&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发<br>
&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发<br>
&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发<br>
&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发<br>
&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发<br>
每天早上6点<br>
0 6 * * *<br>
每两个小时<br>
0 */2 * * *<br>
晚上11点到早上8点之间每两个小时，早上八点<br>
0 23-7/2，8 * * *<br>
每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点<br>
0 11 4 * 1-3<br>
1月1日早上4点<br>
0 4 1 1 *</p>
<p><strong>linux防火墙命令</strong><br>
netstat -anp   查看当前开放端口<br>
firewall-cmd --zone=public --add-port=6030/tcp --permanent  开放端口<br>
firewall-cmd --reload  重新加载端口，开放端口后需要重新reload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[taos数据库]]></title>
        <id>https://spark-wz.github.io/post/taos-shu-ju-ku/</id>
        <link href="https://spark-wz.github.io/post/taos-shu-ju-ku/">
        </link>
        <updated>2020-05-12T06:38:25.000Z</updated>
        <content type="html"><![CDATA[<p>TDengine要求每个数据点单独建表，系统中表的数量和采集点点的数量在一个量级.<br>
超级表(STable)是同一类型数据采集点的抽象，是同类型采集实例的集合，包含多张数据结构一样的子表。<br>
TDengine使用标准SQL语法定义表，使用关键词tags指定标签信息<br>
create table &lt;stable_name&gt;(&lt;field_name&gt; timestamp,field_name1 field_type,……) tags(tag_name tag_type,…)</p>
<p>实例<br>
create table thermometer (ts timestamp, degree float)<br>
tags (location binary(20),type int);</p>
<p>沿用例子，使用超级表建立单个温度计数据表</p>
<p>create table t1 using thermometer tags('beijing',10);</p>
<p>tags字段的名称和类型：</p>
<p>1.tags总长度不能超过512bytes。<br>
2.tags列的数据类型不能是timestamp。<br>
3.tags列名不能与其他列名相同。<br>
4.tags列名不能为预留关键字。</p>
<p>删除STable时，所有通过该STable时，所有通过该超级表建立的表都会被删除。</p>
<p>查看属于某STable并满足查询条件的表<br>
SELECT TBNAME,[TAG_NAME,…] FROM &lt;stable_name&gt; WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)</p>
<p>查询过程中可以加条件计数啥的</p>
<p>#写数据时自动建子表</p>
<p>自动建表只能建立子表不能建立超级表<br>
INSERT INTO &lt;tb_name&gt; USING &lt;stb_name&gt; TAGS (&lt;tag1_value&gt;, ...) VALUES (field_value, ...) (field_value, ...) ...;</p>
<p>#STable中tag管理</p>
<p>添加新标签<br>
alter table &lt;stable_name&gt; add tag&lt;new_tag_name&gt; <type><br>
删除标签<br>
drop tag<br>
修改 change<br>
修改子表标签值<br>
alter table &lt;table_name&gt; set tag &lt;tag_name&gt;=&lt;new_tag_value&gt;</p>
<p>#STable多表聚合</p>
<p>针对超级表子表进行多表聚合查询，支持按照全部的tag值进行条件过滤，不支持binary类型的模糊查询</p>
<p>SELECT function&lt;field_name&gt;,…<br>
FROM &lt;stable_name&gt;<br>
WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)<br>
INTERVAL (<time range>)<br>
GROUP BY &lt;tag_name&gt;, &lt;tag_name&gt;…<br>
ORDER BY &lt;tag_name&gt; &lt;asc|desc&gt;<br>
SLIMIT &lt;group_limit&gt;<br>
SOFFSET &lt;group_offset&gt;<br>
LIMIT &lt;record_limit&gt;<br>
OFFSET &lt;record_offset&gt;<br>
超级表聚合查询，TDengine目前支持sum、count、avg、first、last、min、max、top、bottom不使用orderBy的查询将会对超级表下满足条件的进行查询</p>
<p>#STable使用实例</p>
<p><strong>在一个服务器上部署多个docker实现负载均衡</strong><br>
在一个服务器上实现负载均衡，当一个docker挂掉，启动另一个docker使项目不会停<br>
demo外链<br>
https://blog.csdn.net/wsbgmofo/article/details/79088186</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序]]></title>
        <id>https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/</id>
        <link href="https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/">
        </link>
        <updated>2020-04-02T09:47:30.000Z</updated>
        <content type="html"><![CDATA[<p>第一步：前端调用wx.login()函数，获取返回的code值。（每次通过wx.login()得到的code值可能不一样）</p>
<p>第二步：传递获取到的code值到服务器端，在服务器端用小程序appid，appsecret等去请求微信服务器，获取openid和session_key。（注：每个微信账号，在每个小程序中获取到的openid是唯一的，它可以作为判断新用户和老用户的依据。）</p>
<p>第三步：将用户openid保存到数据库，并将用户id返回到前端，放到缓存中保持登录态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python BeautifulSoup]]></title>
        <id>https://spark-wz.github.io/post/python-beautifulsoup/</id>
        <link href="https://spark-wz.github.io/post/python-beautifulsoup/">
        </link>
        <updated>2020-04-01T08:42:35.000Z</updated>
        <content type="html"><![CDATA[<p>BeautifulSoup是一个可以从html或者xml中提取数据的Python库。<br>
BeautifulSoup最常用解析器（lxml）效率最高<br>
soup = BeautifulSoup(rurl,'lxml')</p>
<p><strong>根据name属性找<br>
soup.name<br>
soup.head 只获取head标签<br>
soup.body.b 获取第一个b标签<br>
通过点取属性的方式只能获得当前名字的第一个tag标签<br>
获取所有的a标签soup.find_all()<br>
soup.find_all('a')</strong></p>
<p><strong>tag的.contains属性可以将tag的子节点以列表的方式输出<br>
字符创没有.contains属性，因为没有子节点。<br>
tag的.children可以对tag的直接子节点循环<br>
for child in title_tag.children:<br>
print(child)<br>
.descendants可以对tag的所有子孙节点进行递归循环<br>
for child in head_tag.descendants:<br>
print(child)</strong></p>
<pre><code>**.parent 可以拿到父节点
html的父节点是BeautifulSoup
.parents可以递归循环所有的父类节点
link = soup.a
</code></pre>
<p>link</p>
<h1 id="a-classsister-hrefhttpexamplecomelsie-idlink1elsiea"><a class="sister" href="http://example.com/elsie" id="link1">Elsie</a></h1>
<p>for parent in link.parents:<br>
if parent is None:<br>
print(parent)<br>
else:<br>
print(parent.name)<br>
**</p>
<p><strong>兄弟节点</strong><br>
sibling_soup.prettify())输出所有兄弟节点<br>
sibling_soup.b.next_sibling 输出后边的兄弟节点</p>
<h1 id="ctext2c"><c>text2</c></h1>
<p>sibling_soup.c.previous_sibling输出前边的兄弟节点</p>
<h1 id="btext1b"><b>text1</b></h1>
<p><strong>正则表达式</strong><br>
re<br>
import re<br>
complie()返回匹配的对象，单独使用没有意义，和find_all搭配使用</p>
<p><strong>true</strong><br>
for tag in soup.find_all(True):<br>
print(tag.name)</p>
<h1 id="html">html</h1>
<h1 id="head">head</h1>
<h1 id="title">title</h1>
<h1 id="body">body</h1>
<h1 id="p">p</h1>
<h1 id="b">b</h1>
<h1 id="p-2">p</h1>
<h1 id="a">a</h1>
<h1 id="a-2">a</h1>
<h1 id="a-3">a</h1>
<h1 id="p-可以匹配任何值但是不会返回字符串节点">p 可以匹配任何值，但是不会返回字符串节点。</h1>
<p><strong>id</strong><br>
soup.find_all(id='link2')<br>
根据id匹配</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL规范]]></title>
        <id>https://spark-wz.github.io/post/mysql-gui-fan/</id>
        <link href="https://spark-wz.github.io/post/mysql-gui-fan/">
        </link>
        <updated>2020-01-06T06:56:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>数据类型</strong><br>
MySQL中小数的数据类型有float（前7）和double（前15），都是浮点类型数都只有前几位准确，不精确，decimal是精确的小数，通常用于货币，计算精确的数。<br>
varchar类型的，如果长度不超过255都用char</p>
<p><strong>基本字段</strong><br>
一般表的基本字段，id、is_deleted(假删除)、c_t、u_t、create_user、update_user、create_user_name、update_user_name</p>
<p><strong>注意事项</strong><br>
记得写注释<br>
记得加默认值，数字的就是0<br>
字符串的就 EMPTY STRING<br>
<img src="https://spark-wz.github.io/post-images/1578298913491.png" alt="" loading="lazy"><br>
如果字符串时null的话，去查的话就很废效率。</p>
<p>前端传给我取钥匙或者存钥匙<br>
把所有状态为空的钥匙柜放在实时页面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[钥匙柜]]></title>
        <id>https://spark-wz.github.io/post/yao-chi-ju/</id>
        <link href="https://spark-wz.github.io/post/yao-chi-ju/">
        </link>
        <updated>2019-12-30T06:25:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>整体流程</strong><br>
从钥匙柜sqlserver数据库里面取数存到mysql中,再从sqlserver中读数给前端。<br>
两张表一张实时表,一张历史表<br>
<strong>要点</strong></p>
<ul>
<li>实时数据<br>
切换到MySQL,从MySQL中读数返给前端,根据时间排序。写一个同步方法，先切换到MySQL中,删除MySQL实时表中的数据,再切换到sqlserver，读取sqlserver中的数据,再切换到MySQL,插入   显示当前所有钥匙状态。<br>
历史数据<br>
同步方法中，切换到MySQL,根据时间排序查到最后一个更新的id,切换到SqlServer,按条件查询，将id大于MySQL最后一个id的记录查出(条件查询)，再切换到MySQL，查到的集合插入。</li>
</ul>
<p>写一个根据前端参数返回数据的方法，返回给前端。<br>
<strong>sqlServer的generator配置</strong><br>
<jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver" connectionURL="jdbc:sqlserver://HQR333TW24G54FN\ADMIN; DatabaseName=I-KeyBox" userId="sa" password="123456"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\ggdon\sqljdbc4-4.0.jar"/><br>
<strong>MySQL的generator配置</strong><br>
<jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://39.97.227.216:3306/gasoline?useUnicode=true&amp;characterEncoding=utf8" userId="root" password="Platform@123"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\apache-maven-3.5.0\repository\mysql\mysql-connector-java\5.1.6\mysql-connector-java-5.1.6.jar"/></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录一次本地jar包导入maven仓库踩到的坑]]></title>
        <id>https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/</id>
        <link href="https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/">
        </link>
        <updated>2019-12-20T02:27:13.000Z</updated>
        <content type="html"><![CDATA[<p>首先将conf/repository中的setttings中的配置文件路径改成自己的路径，要不会报一个路径不对的错，如下<br>
<img src="https://spark-wz.github.io/post-images/1576809073329.png" alt="" loading="lazy"><br>
改成自己的路径之后使用mvn命令直接将jar包导入自己的maven仓库，设置好依赖的3个属性。<br>
将jar包放到lib目录下<br>
mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.7.jar -DgroupId=com.wz.package -DartifactId=modbus4j -Dversion=2.0.7 -Dpackaging=jar<br>
其中Dfile是当前目录加jar包全称，DgroupId 可以随便起，DartifactId一般是jar包名,Dversion是版本号。</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/serotonin-timer-2.0.6.jar -DgroupId=com.wz.package -DartifactId=serotonin-timer -Dversion=2.0.6 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/commons-logging-1.2.jar -DgroupId=com.wz.package -DartifactId=commons-logging -Dversion=1.2 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/sqljdbc4-3.0.jar -DgroupId=com.wz.package -DartifactId=sqljdbc4 -Dversion=3.0 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.2.jar -DgroupId=com.wz.package -DartifactId=modbus4j2 -Dversion=2.0.2 -Dpackaging=jar</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式]]></title>
        <id>https://spark-wz.github.io/post/lambda-biao-da-shi/</id>
        <link href="https://spark-wz.github.io/post/lambda-biao-da-shi/">
        </link>
        <updated>2019-12-18T01:38:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简介</strong><br>
Lambda表达式是一个匿名函数，简单来说就是一种没有声明的方法，即没有访问修饰符，返回值声明和名称。<br>
在仅编写一次方法的地方特别有用，方法定义很短，他为我们节省了，包含类声明和编写单独方法的工作。<br>
Java中的Lambda表达式通常使用语法是(argument) -&gt; (body)</p>
<p>以下是Lambda表达式的一些实例</p>
<p>(int a, int b) -&gt; { return a + b;}<br>
() -&gt; System.out.println(&quot;Hello World&quot;);<br>
(String s) -&gt; {System.out.println(s);}<br>
() -&gt; 42<br>
() -&gt; { return 3.1415};</p>
<p>**Lambda 表达式的结构</p>
<p>Lambda 表达式可以具有零个，一个或多个参数。<br>
可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如 (int a) 与刚才相同 (a)。<br>
参数用小括号括起来，用逗号分隔。例如 (a, b) 或 (int a, int b) 或 (String a, int b, float c)。<br>
空括号用于表示一组空的参数。例如 () -&gt; 42。<br>
当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 a -&gt; return a*a。<br>
Lambda 表达式的正文可以包含零条，一条或多条语句。<br>
如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。<br>
如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。</p>
<p><strong>4.2 使用方式</strong><br>
双冒号(::)操作符是java的方法引用。当我们使用一个方法的引用时，目标引用放在冒号前，目标引用提供的方法在：：之后。即目标引用::方法。<br>
person::getAge;<br>
在person类中定义的方法getAge的引用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合常用]]></title>
        <id>https://spark-wz.github.io/post/java/</id>
        <link href="https://spark-wz.github.io/post/java/">
        </link>
        <updated>2019-12-11T07:14:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>java中将数组转为list</strong><br>
String[] myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List<String> myList = Arrays.asList(myArray);<br>
但是这个方法将数组转为集合后，集合的底层还是数组<img src="https://spark-wz.github.io/post-images/1576048771521.jpg" alt="" loading="lazy"><br>
2.传递的对象必须是基本对象，不能是包装类<br>
int[] myArray = { 1, 2, 3 };<br>
List myList = Arrays.asList(myArray);<br>
System.out.println(myList.size());//1<br>
System.out.println(myList.get(0));//数组地址值<br>
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException<br>
当传入原生数据类型是,myList.get(0)拿到的是数组本身，而不是第一个值<br>
List myList = Arrays.asList(1, 2, 3);<br>
myList.add(4);//运行时报错：UnsupportedOperationException<br>
myList.remove(1);//运行时报错：UnsupportedOperationException<br>
myList.clear();//运行时报错：UnsupportedOperationException<br>
在使用add(),remove(),clear()会报错<br>
<em>正确的最简便的方法</em><br>
String myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List list = new ArrayList&lt;&gt;(Arrays.asList(myArray));</p>
<p><strong>遍历Map</strong></p>
<p>1.通过map.keySet()</p>
<p>通过key去获取value<br>
Set<Integer> set = map.keySet();</p>
<p>for (Integer integer: set) {</p>
<p>System.out.println(integer +&quot;的对应值为:&quot; + map.get(integer));</p>
<p>}<br>
2.通过map.values遍历所有的value</p>
<p>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();<br>
map.put(1,1);<br>
map.put(2,2);<br>
map.put(3,3);<br>
Collection<Integer> values = map.values();<br>
for (Integer value : values) {<br>
System.out.println(&quot;value = &quot; + value);<br>
}<br>
3.遍历map.entrySet</p>
<p>遍历map.entrySet,可同时拿到所有的KEY和VALUE<br>
Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>
for (Map.Entry&lt;Integer, Integer&gt; entry : entries) {<br>
System.out.println(&quot;entry.getValue() = &quot; + entry.getValue());<br>
}</p>
<p>4.lambda表达式</p>
<p>map.forEach((key,value) -&gt;{<br>
System.out.println(&quot;key = &quot; + key+&quot;value = &quot;+value);<br>
});</p>
]]></content>
    </entry>
</feed>