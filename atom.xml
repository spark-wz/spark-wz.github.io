<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2020-07-02T10:29:20.583Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[参数sql]]></title>
        <id>https://spark-wz.github.io/post/can-shu-sql</id>
        <link href="https://spark-wz.github.io/post/can-shu-sql">
        </link>
        <updated>2020-07-02T02:28:01.000Z</updated>
        <content type="html"><![CDATA[<p>select count(pp) from test where pp='立项' or pp='签约' or pp='已完成' or pp='引入经费计划'   历年累计立项数<br>
select count(pp) from test where pp='规划' or pp='立项' or pp='进行中' or pp='已完成' or pp='引入经费计划'  规划新上项目数<br>
select count(pp) from test where pp='已完成' and importance = '重点项目'  实际完成重点项目数<br>
select count(pp) from test 规划任务总量<br>
select count(pp) from test where pp='已完成' and importance = '一般项目' 实际完成一般项目数量<br>
select sum(funds_allocated) from test where importance = '重点项目' 以拨付重点项目经费<br>
select sum(funds) from test;  规划经费总额<br>
select sum(funds_allocated) from test where importance = '一般项目' 以拨付一般项目经费<br>
select count (id) from test where funds_allocated &gt; funds and importance = '重点项目'    超概算重点项目数量<br>
select count (id) from test where funds_allocated &gt; funds and importance = '一般项目'    超概算一般项目数量<br>
select sum (funds_allocated - funds) from test where funds_allocated &gt; funds and importance = '重点项目'    超概算重点项目金额<br>
select sum (funds_allocated - funds) from test where funds_allocated &gt; funds and importance = '一般项目'    超概算一般项目金额<br>
select count(id) from test where pp='立项' or pp='进行中' or pp='已完成' and importance = '重点项目' and year = ?' 年度新上重点项目已立项数<br>
select count(id) from test where pp='立项' or pp='进行中' or pp='已完成' and importance = '一般项目' and year = ? 年度新上一般项目已立项数<br>
select count(id) from test  year = ? 年度新上项目数<br>
select count(id) from test  year = ? 年度总项目数<br>
select count(id) from test where  pp='进行中' or pp='已完成' and importance = '重点项目' and year = ?' 年度签订重点项目合同数<br>
select count(id) from test where  pp='进行中' or pp='已完成' and importance = '一般项目' and year = ? 年度签订一般项目合同数<br>
select count(id) from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '重点项目' and year = ?' 列入经费计划的重点项目数<br>
select count(id) from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '一般项目' and year = ? 列入经费计划的一般项目数<br>
select sum(funds_allocated)  from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '重点项目' 列入经费计划的重点项目已拨付经费数<br>
select sum(funds_allocated)  from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '一般项目' 列入经费计划的一般项目已拨付经费数<br>
select count (importance) from test where importance='重点项目' and pp = '已完成'   已完成重点项目数<br>
select count (importance)  from test where importance='一般项目' and pp = '已完成'   已完成一般项目数<br>
select count (id)  from test where competition_and_selection ='是' and importance = '重点项目'  竞争择优确定的重点项目数<br>
select count (id)  from test where competition_and_selection ='是' and importance = '一般项目'  竞争择优确定的一般项目数<br>
select count(software_or_hardware) from test where software_or_hardware='软件'  软件项目总数<br>
select count(is_private) from test  总承研单位数量<br>
select count(is_private) from test where importance='重点项目' and is_private='是'   重点项目民营承研单位数量<br>
select count(is_private) from test where importance='一般项目' and is_private='是'   一般项目民营承研单位数量<br>
select count(domestic_sw) from test where importance = '重点项目'<br>
重点项目国产化软件数<br>
select count(domestic_sw) from test where importance = '一般项目'<br>
一般项目国产化软件数<br>
select sum(total_part) from test 项目零部件总数<br>
select sum(domestic_part) from test where importance = '重点项目'<br>
重点项目国产化零部件数<br>
select sum(domestic_part) from test where importance = '一般项目'<br>
一般项目国产化零部件数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nodejs]]></title>
        <id>https://spark-wz.github.io/post/nodejs</id>
        <link href="https://spark-wz.github.io/post/nodejs">
        </link>
        <updated>2020-07-01T04:01:49.000Z</updated>
        <content type="html"><![CDATA[<p>//person对象<br>
function Person(id, year, project, importance,pp,funds,funds_allocated,software_or_hardware,competition_and_selection,domestic_part,research_unit,is_private) {<br>
this.id = id;<br>
this.year = year;<br>
this.project = project;<br>
this.importance = importance;<br>
this.pp = pp;<br>
this.funds = funds;<br>
this.funds_allocated = funds_allocated;<br>
this.software_or_hardware = software_or_hardware;<br>
this.competition_and_selection = competition_and_selection;<br>
this.domestic_part = domestic_part;<br>
this.research_unit = research_unit;<br>
this.is_private = is_private;<br>
}<br>
function Person(id, year, project, importance,pp,funds,funds_allocated,software_or_hardware,competition_and_selection,domestic_part,research_unit,is_private) {<br>
}<br>
//set方法<br>
Person.prototype.setId=function (id) {<br>
this.id = id;<br>
}<br>
Person.prototype.setYear=function (year) {<br>
this.year = year;<br>
}<br>
Person.prototype.setProject=function (project) {<br>
this.project = project;<br>
}<br>
Person.prototype.setImportance=function (importance) {<br>
this.importance = importance;<br>
}<br>
Person.prototype.setPp=function (pp) {<br>
this.pp = pp;<br>
}<br>
Person.prototype.setFunds=function (funds) {<br>
this.funds = funds;<br>
}<br>
Person.prototype.setAllocated=function (funds_allocated) {<br>
this.funds_allocated = funds_allocated;<br>
}<br>
Person.prototype.setSoftware=function (software_or_hardware) {<br>
this.software_or_hardware = software_or_hardware;<br>
}<br>
Person.prototype.setCompetition=function (competition_and_selection) {<br>
this.competition_and_selection = competition_and_selection;<br>
}<br>
Person.prototype.setDomestic=function (domestic_part) {<br>
this.domestic_part = domestic_part;<br>
}<br>
Person.prototype.setResearch=function (research_unit) {<br>
this.research_unit = research_unit;<br>
}<br>
Person.prototype.setPrivate=function (is_private) {<br>
this.is_private = is_private;<br>
}<br>
//get方法<br>
Person.prototype.getId=function () {<br>
return this.id ;<br>
}<br>
Person.prototype.getYear=function () {<br>
return this.year;<br>
}<br>
Person.prototype.getProject=function () {<br>
return this.project ;<br>
}<br>
Person.prototype.getImportance=function () {<br>
return this.importance;<br>
}<br>
Person.prototype.getPp=function () {<br>
return this.pp ;<br>
}<br>
Person.prototype.getFunds=function () {<br>
return this.funds;<br>
}<br>
Person.prototype.getAllocated=function () {<br>
return this.funds_allocated ;<br>
}<br>
Person.prototype.getSoftware=function () {<br>
return this.software_or_hardware;<br>
}<br>
Person.prototype.getCompetition=function () {<br>
return this.competition_and_selection;<br>
}<br>
Person.prototype.getDomestic=function () {<br>
return this.domestic_part ;<br>
}<br>
Person.prototype.getResearch=function () {<br>
return this.research_unit;<br>
}<br>
Person.prototype.getPrivate=function () {<br>
return this.is_private;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6.28]]></title>
        <id>https://spark-wz.github.io/post/628</id>
        <link href="https://spark-wz.github.io/post/628">
        </link>
        <updated>2020-06-28T02:02:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="需求">需求</h1>
<h3 id="项目资料">项目资料</h3>
<p>增删改，如果是对数据库操作，需要excel导出，如果excel，不需要导出</p>
<h3 id="指标公式">指标公式</h3>
<p>从excel或者txt中读取，初始显示已有公式 可以编辑<br>
如果是对数据库操作，需要excel导出，如果excel，不需要导出</p>
<h3 id="单年度结果查看">单年度结果查看</h3>
<p>在项目资料的参数中，统计出指标所需要的参数，计算完成率，在页面上显示统计结果，加图表，将结果导出word</p>
<h3 id="多年度结果查看">多年度结果查看</h3>
<p>计算多年年度结果，页面显示结果加图表对比，支持导出word<br>
npm install sqlite3 --save</p>
<p>UPDATE &quot;main&quot;.&quot;test&quot; SET &quot;year&quot;=202, &quot;project&quot;=2, &quot;importance&quot;=2, &quot;pp&quot;=2, &quot;funds&quot;=2, &quot;funds_allocated&quot;=2, &quot;software_or_hardware&quot;=2, &quot;competition_and_selection&quot;=2, &quot;domestic_part&quot;=2, &quot;research_unit&quot;=22, &quot;is_private&quot;=2 WHERE (&quot;id&quot;=10)</p>
<p>参数一  运算符   参数二     权重   百分比    运算    参数三  运算符  参数四      权重    百分比  type</p>
<p>// 添加<br>
function insert(info) {<br>
insert.run(&quot;INSERT INTO &quot;main&quot;.&quot;test&quot; (&quot;year&quot;, &quot;project&quot;, &quot;importance&quot;, &quot;pp&quot;, &quot;funds&quot;, &quot;funds_allocated&quot;, &quot;software_or_hardware&quot;, &quot;competition_and_selection&quot;, &quot;domestic_part&quot;, &quot;research_unit&quot;, &quot;is_private&quot;, &quot;domestic_sw&quot;, &quot;project_function&quot;, &quot;goal&quot;,&quot;total_part&quot;) VALUES (&quot;+info.year+&quot;, &quot;+info.project+&quot;, &quot;+info.importance+&quot;, &quot;+info.pp+&quot;, &quot;+info.funds+&quot;, &quot;+info.funds_allocated+&quot;, &quot;+info.software_or_hardware+&quot;, &quot;+info.competition_and_selection+&quot;, &quot;+info.domestic_part+&quot;, &quot;+info.research_unit+&quot;, &quot;+info.is_private+&quot;, &quot;+info.domestic_sw+&quot;, &quot;+info.project_function+&quot;, &quot;+info.goal+&quot;, &quot;+info.total_part+&quot;)&quot;,function (err) {<br>
if(null != err){<br>
DB.printErrorInfo(err);<br>
}else {<br>
return 1;<br>
};<br>
});<br>
}<br>
//更新<br>
function update(info) {<br>
update.run(&quot;UPDATE &quot;main&quot;.&quot;test&quot; SET &quot;year&quot;=&quot;+info.year+&quot;, &quot;project&quot;=&quot;+info.project+&quot;, &quot;importance&quot;=&quot;+info.importance+&quot;, &quot;pp&quot;=&quot;+info.pp+&quot;, &quot;funds&quot;=&quot;+info.funds+&quot;, &quot;funds_allocated&quot;=&quot;+info.funds_allocated+&quot;, &quot;software_or_hardware&quot;=&quot;+info.software_or_hardware+&quot;, &quot;competition_and_selection&quot;=&quot;+info.competition_and_selection+&quot;, &quot;domestic_part&quot;=&quot;+info.domestic_part+&quot;, &quot;research_unit&quot;=&quot;+info.research_unit+&quot;, &quot;is_private&quot;=&quot;+info.is_private+&quot;, &quot;domestic_sw&quot;=&quot;+info.domestic_sw+&quot;, &quot;project_function&quot;=&quot;+info.project_function+&quot;, &quot;goal&quot;=&quot;+info.goal+&quot;, &quot;total_part&quot;=&quot;+info.total_part+&quot; WHERE (&quot;id&quot;=&quot;+info.id+&quot; )&quot;,function (err) {<br>
if(null != err){<br>
DB.printErrorInfo(err);<br>
}else {<br>
return 1;<br>
};<br>
});<br>
}</p>
<p>UPDATE &quot;main&quot;.&quot;test&quot; SET &quot;year&quot;=11, &quot;project&quot;=1, &quot;importance&quot;=111, &quot;pp&quot;=111, &quot;funds&quot;=1111, &quot;funds_allocated&quot;=111, &quot;software_or_hardware&quot;=111, &quot;competition_and_selection&quot;=111, &quot;domestic_part&quot;=111, &quot;research_unit&quot;=11, &quot;is_private&quot;=11, &quot;domestic_sw&quot;=1, &quot;project_function&quot;=1, &quot;goal&quot;=1, &quot;total_part&quot;=1 WHERE (&quot;id&quot;=11)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node]]></title>
        <id>https://spark-wz.github.io/post/node</id>
        <link href="https://spark-wz.github.io/post/node">
        </link>
        <updated>2020-06-27T12:26:19.000Z</updated>
        <content type="html"><![CDATA[<p>npm config set prefix &quot;D:\tools\node\node_global&quot;<br>
npm config set cache &quot;D:\tools\node\node_cache&quot;</p>
<p>proxy=null<br>
registry=http://registry.npm.taobao.org/<br>
prefix=D:\tools\node\node_global<br>
cache=D:\tools\node\node_cache</p>
<p>npm config set registry http://registry.npm.taobao.org<br>
npm install express -g<br>
npm install -g express-generator</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rocket Mq]]></title>
        <id>https://spark-wz.github.io/post/rocket-mq</id>
        <link href="https://spark-wz.github.io/post/rocket-mq">
        </link>
        <updated>2020-06-24T08:46:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<ol>
<li>Producer(生产者)  Producer Group(消息生产者组)</li>
<li>Consumer(消费者)  Consumer Group（消费同类消息的多个实例）</li>
<li>Broker(包括接收请求，处理消费，消费持久，消息的HA，以及服务端过滤等)MQ程序，接受生产者信息，提供给消费者消费</li>
<li>Topic(消息主题通过topic对不同的消息进行分类) Tag(对topic的进一步细化)</li>
<li>Message Queue(消息队列,必须指定Topic)</li>
<li>NameServer(负责producer、Consumer和Broker之间的协调，可以多个部署，相互独立)</li>
<li>Offset （偏移量，相当于消息进度）</li>
<li>Commit Log（消息存储会写在Commit Log文件里面）</li>
</ol>
<h3 id="职能图示">职能图示</h3>
<p><img src="https://spark-wz.github.io/post-images/1592989472723.png" alt=""></p>
<h3 id="消费者类型">消费者类型</h3>
<ol>
<li>PushConsumer 使用简单，只需要设置订阅参数和消息处理方法，系统自动保存offset。</li>
<li>PullConsumer可控性更高，可以设定拉取时间、控制offset。</li>
</ol>
<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Modbus RTU]]></title>
        <id>https://spark-wz.github.io/post/ce-shi</id>
        <link href="https://spark-wz.github.io/post/ce-shi">
        </link>
        <updated>2020-06-08T01:33:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows">Windows</h3>
<h4 id="依赖">依赖</h4>
<ol>
<li>Windows中需要的依赖 modbus4J-1.0.jar（modbus4j，用户modbus协议工具类，导入maven仓库）、RXTXcomm.jar（版本为2.1.7，需要和java环境中的dll文件相对应）、seroUtils-3.0.jar，目录都在/resources/libs中</li>
<li>需要的dll文件为rxtxParallel.dll、rxtxSerial.dll 版本都是2.1.7 。 存放位置在jre/bin目录下: D:\Program Files\java\jre\bin<br>
####实现</li>
<li>创建SerialParameters实例<br>
SerialParameters serialParameters = new SerialParameters();</li>
<li>设定从站地址（slaveId）、串行口波特率、设定串行口名称（区分大小写）、设定无奇偶校验、设定数据位、设定停止位、设定从站名称，<br>
<img src="https://spark-wz.github.io/post-images/1592897149873.png" alt=""></li>
<li>创建ModbusFactory工厂实例，将SerialParameters作为参数创建ModbusMaster实例。<br>
<img src="https://spark-wz.github.io/post-images/1592897345686.png" alt=""></li>
<li>初始化<br>
<img src="https://spark-wz.github.io/post-images/1592897399514.png" alt=""></li>
<li>读取串口数据</li>
<li>创建读取请求，设定从站id、开始位、读取位数</li>
<li>主站发送请求，获取结果</li>
<li>异常判断，转换结果格式<br>
<img src="https://spark-wz.github.io/post-images/1592897782379.png" alt=""></li>
</ol>
<h3 id="树莓派">树莓派</h3>
<h4 id="环境-当前重启丢失java环境删除部分文件">环境   (当前重启丢失java环境，删除部分文件)</h4>
<ol>
<li>烧写树莓派系统，测试树莓派功能。切换root用户，sudo su root 设定密码</li>
<li>jdk环境<br>
树莓派为arm32位系统，安装arm32位jdk，本地jdk包在D:\chrome\Downloads下，安装目录为/usr/local 将jdk-8u251-linux-arm32-vfp-hflt.tar.gz解压在当前目录。编辑vi /etc/profile在文件最下边加入配置<br>
export JAVA_HOME=/usr/local/jdk1.8.0_251<br>
export PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>i</mi><mi>n</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/bin:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>PATH<br>
export CLASSPATH=.:JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar<br>
刷新配置文件source /etc/profile</li>
<li>配置modbus RXTX环境（等同于rxtxParallel.dll、rxtxSerial.dll配置，需要版本都为2.1.7）</li>
<li>切换目录 cd /tmp</li>
<li>下载wget http://rxtx.qbang.org/pub/rxtx/rxtx-2.1-7r2.zip ，解压到当前目录</li>
<li>使用uname-r 命令查看当前系统版本信息，当前树莓派系统版本为4.14.90-v7+；编辑 vi /usr/include/linux/version.h文件，在文件最后一行加入 （#define UTS_RELEASE &quot;4.14.90-v7+&quot;）</li>
<li>由于RXTX没有为arm32位系统的版本，所以需要自己编译，打开刚才解压的目录 编辑configure，在文档里面找到所有的1.2*|1.3*|1.4*|1.5*，都替换为1.2*|1.3*|1.4*|1.5*|1.6*|1.7*|1.8*，更改过的configure在D:\tools\grIdea\images目录下。完成后开始编译、安装 ./configure   make   make install</li>
<li>由于编译过的RXTX只支持ttyS开头的串口，所以要做串口映射（ ln -s /dev/ttyUSB2 /dev/ttyS145），将/dev/ttyUSB2串口映射为ttyS145,在代码中读取ttyS145串口。</li>
<li>在代码中串口名参数不能直接为ttyS145，应为(/dev/ttyS145)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时任务@Scheduled]]></title>
        <id>https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled</id>
        <link href="https://spark-wz.github.io/post/ding-shi-ren-wu-scheduled">
        </link>
        <updated>2020-05-18T01:26:17.000Z</updated>
        <content type="html"><![CDATA[<p>字段 允许值 允许的特殊字符<br>
秒 0-59 , - * /<br>
分 0-59 , - * /<br>
小时 0-23 , - * /<br>
日期 1-31 , - * ? / L W C<br>
月份 1-12 或者 JAN-DEC , - * /<br>
星期 1-7 或者 SUN-SAT , - * ? / L C #<br>
年（可选） 留空, 1970-2099 , - * /<br>
表达式意义<br>
&quot;0 0 12 * * ?&quot; 每天中午12点触发<br>
&quot;0 15 10 ? * *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ?&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? *&quot; 每天上午10:15触发<br>
&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发<br>
&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发<br>
&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发<br>
&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>
&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发<br>
&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发<br>
&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发<br>
&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发<br>
&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发<br>
&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发<br>
&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发<br>
每天早上6点<br>
0 6 * * *<br>
每两个小时<br>
0 */2 * * *<br>
晚上11点到早上8点之间每两个小时，早上八点<br>
0 23-7/2，8 * * *<br>
每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点<br>
0 11 4 * 1-3<br>
1月1日早上4点<br>
0 4 1 1 *</p>
<p><strong>linux防火墙命令</strong><br>
netstat -anp   查看当前开放端口<br>
firewall-cmd --zone=public --add-port=6030/tcp --permanent  开放端口<br>
firewall-cmd --reload  重新加载端口，开放端口后需要重新reload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[taos数据库]]></title>
        <id>https://spark-wz.github.io/post/taos-shu-ju-ku</id>
        <link href="https://spark-wz.github.io/post/taos-shu-ju-ku">
        </link>
        <updated>2020-05-12T06:38:25.000Z</updated>
        <content type="html"><![CDATA[<p>TDengine要求每个数据点单独建表，系统中表的数量和采集点点的数量在一个量级.<br>
超级表(STable)是同一类型数据采集点的抽象，是同类型采集实例的集合，包含多张数据结构一样的子表。<br>
TDengine使用标准SQL语法定义表，使用关键词tags指定标签信息<br>
create table &lt;stable_name&gt;(&lt;field_name&gt; timestamp,field_name1 field_type,……) tags(tag_name tag_type,…)</p>
<p>实例<br>
create table thermometer (ts timestamp, degree float)<br>
tags (location binary(20),type int);</p>
<p>沿用例子，使用超级表建立单个温度计数据表</p>
<p>create table t1 using thermometer tags('beijing',10);</p>
<p>tags字段的名称和类型：</p>
<p>1.tags总长度不能超过512bytes。<br>
2.tags列的数据类型不能是timestamp。<br>
3.tags列名不能与其他列名相同。<br>
4.tags列名不能为预留关键字。</p>
<p>删除STable时，所有通过该STable时，所有通过该超级表建立的表都会被删除。</p>
<p>查看属于某STable并满足查询条件的表<br>
SELECT TBNAME,[TAG_NAME,…] FROM &lt;stable_name&gt; WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)</p>
<p>查询过程中可以加条件计数啥的</p>
<p>#写数据时自动建子表</p>
<p>自动建表只能建立子表不能建立超级表<br>
INSERT INTO &lt;tb_name&gt; USING &lt;stb_name&gt; TAGS (&lt;tag1_value&gt;, ...) VALUES (field_value, ...) (field_value, ...) ...;</p>
<p>#STable中tag管理</p>
<p>添加新标签<br>
alter table &lt;stable_name&gt; add tag&lt;new_tag_name&gt; <type><br>
删除标签<br>
drop tag<br>
修改 change<br>
修改子表标签值<br>
alter table &lt;table_name&gt; set tag &lt;tag_name&gt;=&lt;new_tag_value&gt;</p>
<p>#STable多表聚合</p>
<p>针对超级表子表进行多表聚合查询，支持按照全部的tag值进行条件过滤，不支持binary类型的模糊查询</p>
<p>SELECT function&lt;field_name&gt;,…<br>
FROM &lt;stable_name&gt;<br>
WHERE &lt;tag_name&gt; &lt;[=|&lt;=|&gt;=|&lt;&gt;] values..&gt; ([AND|OR] …)<br>
INTERVAL (<time range>)<br>
GROUP BY &lt;tag_name&gt;, &lt;tag_name&gt;…<br>
ORDER BY &lt;tag_name&gt; &lt;asc|desc&gt;<br>
SLIMIT &lt;group_limit&gt;<br>
SOFFSET &lt;group_offset&gt;<br>
LIMIT &lt;record_limit&gt;<br>
OFFSET &lt;record_offset&gt;<br>
超级表聚合查询，TDengine目前支持sum、count、avg、first、last、min、max、top、bottom不使用orderBy的查询将会对超级表下满足条件的进行查询</p>
<p>#STable使用实例</p>
<p><strong>在一个服务器上部署多个docker实现负载均衡</strong><br>
在一个服务器上实现负载均衡，当一个docker挂掉，启动另一个docker使项目不会停<br>
demo外链<br>
https://blog.csdn.net/wsbgmofo/article/details/79088186</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序]]></title>
        <id>https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu</id>
        <link href="https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu">
        </link>
        <updated>2020-04-02T09:47:30.000Z</updated>
        <content type="html"><![CDATA[<p>第一步：前端调用wx.login()函数，获取返回的code值。（每次通过wx.login()得到的code值可能不一样）</p>
<p>第二步：传递获取到的code值到服务器端，在服务器端用小程序appid，appsecret等去请求微信服务器，获取openid和session_key。（注：每个微信账号，在每个小程序中获取到的openid是唯一的，它可以作为判断新用户和老用户的依据。）</p>
<p>第三步：将用户openid保存到数据库，并将用户id返回到前端，放到缓存中保持登录态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python BeautifulSoup]]></title>
        <id>https://spark-wz.github.io/post/python-beautifulsoup</id>
        <link href="https://spark-wz.github.io/post/python-beautifulsoup">
        </link>
        <updated>2020-04-01T08:42:35.000Z</updated>
        <content type="html"><![CDATA[<p>BeautifulSoup是一个可以从html或者xml中提取数据的Python库。<br>
BeautifulSoup最常用解析器（lxml）效率最高<br>
soup = BeautifulSoup(rurl,'lxml')</p>
<p><strong>根据name属性找<br>
soup.name<br>
soup.head 只获取head标签<br>
soup.body.b 获取第一个b标签<br>
通过点取属性的方式只能获得当前名字的第一个tag标签<br>
获取所有的a标签soup.find_all()<br>
soup.find_all('a')</strong></p>
<p><strong>tag的.contains属性可以将tag的子节点以列表的方式输出<br>
字符创没有.contains属性，因为没有子节点。<br>
tag的.children可以对tag的直接子节点循环<br>
for child in title_tag.children:<br>
print(child)<br>
.descendants可以对tag的所有子孙节点进行递归循环<br>
for child in head_tag.descendants:<br>
print(child)</strong></p>
<pre><code>**.parent 可以拿到父节点
html的父节点是BeautifulSoup
.parents可以递归循环所有的父类节点
link = soup.a
</code></pre>
<p>link</p>
<h1 id="a-classsister-hrefhttpexamplecomelsie-idlink1elsiea"><a class="sister" href="http://example.com/elsie" id="link1">Elsie</a></h1>
<p>for parent in link.parents:<br>
if parent is None:<br>
print(parent)<br>
else:<br>
print(parent.name)<br>
**</p>
<p><strong>兄弟节点</strong><br>
sibling_soup.prettify())输出所有兄弟节点<br>
sibling_soup.b.next_sibling 输出后边的兄弟节点</p>
<h1 id="ctext2c"><c>text2</c></h1>
<p>sibling_soup.c.previous_sibling输出前边的兄弟节点</p>
<h1 id="btext1b"><b>text1</b></h1>
<p><strong>正则表达式</strong><br>
re<br>
import re<br>
complie()返回匹配的对象，单独使用没有意义，和find_all搭配使用</p>
<p><strong>true</strong><br>
for tag in soup.find_all(True):<br>
print(tag.name)</p>
<h1 id="html">html</h1>
<h1 id="head">head</h1>
<h1 id="title">title</h1>
<h1 id="body">body</h1>
<h1 id="p">p</h1>
<h1 id="b">b</h1>
<h1 id="p-2">p</h1>
<h1 id="a">a</h1>
<h1 id="a-2">a</h1>
<h1 id="a-3">a</h1>
<h1 id="p-可以匹配任何值但是不会返回字符串节点">p 可以匹配任何值，但是不会返回字符串节点。</h1>
<p><strong>id</strong><br>
soup.find_all(id='link2')<br>
根据id匹配</p>
]]></content>
    </entry>
</feed>