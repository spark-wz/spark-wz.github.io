<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2020-09-10T03:02:54.111Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[java线程]]></title>
        <id>https://spark-wz.github.io/post/java-xian-cheng</id>
        <link href="https://spark-wz.github.io/post/java-xian-cheng">
        </link>
        <updated>2020-09-09T09:10:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进程与线程">进程与线程</h1>
<p>一个程序至少有一个进程，一个进程至少有一个线程。<br>
线程的划分尺度小于进程，使得多进程程序的并发性高。<br>
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>
在java中，每次程序至少启用两个线程，一个是main线程，一个是垃圾回收线程，因为当使用java命令执行一个类的同时，实际上都会启用一个jvm，每一个jvm实际上就是在操作系统中启动了一个进程。</p>
<h1 id="java线程">java线程</h1>
<p>java中，线程指两件不同的事情</p>
<ol>
<li>java.lang.Thread类的一个实例</li>
<li>线程的执行</li>
</ol>
<h4 id="创建线程">创建线程</h4>
<ol>
<li>对Thread类进行派生并覆盖run方法</li>
<li>通过实现Runnable接口创建。<br>
使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义，实例化和启动新线程。<br>
一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。<br>
Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。<br>
一个Java应用总是从main()方法开始运行，main()方法运行在一个线程内，他被称为主线程。<br>
一旦创建一个新的线程，就产生一个新的调用栈。<br>
线程总体分两类：用户线程和守候线程。<br>
当所有线程执行完毕的时候，jvm自动关闭，但是守护线程部不独立于jvm，守护线程一般由操作系统或者用户创建的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[9.10现场任务]]></title>
        <id>https://spark-wz.github.io/post/910-xian-chang-ren-wu</id>
        <link href="https://spark-wz.github.io/post/910-xian-chang-ren-wu">
        </link>
        <updated>2020-09-08T07:15:36.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>备份nginx.conf</li>
<li>安装ffmpeg，调试摄像头。</li>
<li>编写摄像头脚本，编写数据库配置</li>
<li>部队首页图</li>
<li>数据库迁移，将军油表迁移到jeecg-boot库中</li>
<li>前端、后端包上传测试（液位，零发油，流量计）</li>
<li>部署单机版</li>
<li>任务确认书</li>
<li>洞库分区名，油罐名</li>
</ul>
<h3 id="液位代码流程">液位代码流程</h3>
<p>查询液位配置表，根据油罐编号排序，查询到所有油罐油罐编号和油罐各数据寄存器地址。建立taos连接，遍历液位配置list，插入taos数据库。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设置服务器自启动脚本]]></title>
        <id>https://spark-wz.github.io/post/she-zhi-fu-wu-qi-zi-qi-dong-jiao-ben</id>
        <link href="https://spark-wz.github.io/post/she-zhi-fu-wu-qi-zi-qi-dong-jiao-ben">
        </link>
        <updated>2020-09-08T07:14:46.000Z</updated>
        <content type="html"><![CDATA[<p>/ 1.前往目录</p>
<p>cd /etc/rc.d/init.d</p>
<p>/2. 新建startup脚本<br>
vi startup.sh</p>
<p>/3.粘贴脚本内容 (注意替换nginx和java项目的路径）</p>
<p>!/bin/bash<br>
chkconfig: 2345 10 90<br>
descriptiom: startup service<br>
cd /usr/local/nginx/sbin<br>
./nginx<br>
service mysql start<br>
source /etc/profile<br>
nohup java -jar /data/service/tl-gasoline/tl-gasoline-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;&gt; catalina.out  2&gt;&amp;1 &amp;<br>
service firewalld stop</p>
<p>/4.增加脚本的可执行权限<br>
chmod +x /etc/rc.d/init.d/startup.sh</p>
<p>/5.添加脚本到开机自动启动项目中<br>
cd /etc/rc.d/init.d<br>
chkconfig --add startup.sh<br>
chkconfig startup.sh on<br>
————————————————</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Modbus连接池]]></title>
        <id>https://spark-wz.github.io/post/you-ku-ping-tai</id>
        <link href="https://spark-wz.github.io/post/you-ku-ping-tai">
        </link>
        <updated>2020-09-04T05:45:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="原理">原理</h3>
<p>申请好与mysql的连接，将连接放入内存中，以后每次需要连接的时候，从连接池内获取连接。</p>
<h3 id="实现">实现</h3>
<p>定义一个DataSource类，这个类负责初始化mysql Connection，以及将释放的mysql连接存储起来，使用LinkedList来作为存储的数据结构（频繁对线程池进行增加和删除）（一个线程来获取就要从池子里删除一个connection，线程运行完就要将connection加入池子）</p>
<h3 id="datasource类">DataSource类</h3>
<p><img src="https://spark-wz.github.io/post-images/1599471940689.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker]]></title>
        <id>https://spark-wz.github.io/post/docker</id>
        <link href="https://spark-wz.github.io/post/docker">
        </link>
        <updated>2020-09-01T14:57:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装docker源">安装Docker源</h3>
<p>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</p>
<h3 id="安装docker">安装Docker</h3>
<p>sudo yum install docker-ce docker-ce-cli containerd.io</p>
<h3 id="启动docker">启动Docker</h3>
<p>systemctl start docker</p>
<h3 id="docker使用">Docker使用</h3>
<p>sudo docker run hello-world</p>
<h3 id="创建文件夹">创建文件夹</h3>
<p>mkdir rootfs</p>
<h3 id="使用busybox镜像创建系统">使用busybox镜像创建系统</h3>
<p>docker export $(docker create busybox) -o busybox.tar</p>
<h3 id="解压">解压</h3>
<p>tar -xf busybox.tar</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[websocket]]></title>
        <id>https://spark-wz.github.io/post/websocket</id>
        <link href="https://spark-wz.github.io/post/websocket">
        </link>
        <updated>2020-07-24T07:20:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>WebSocket是基于tcp的一种新的网络协议，它实现了浏览器与服务器之间双全工通信，允许服务器主动发信息给客户端。</p>
<h2 id="原理">原理</h2>
<p>在实现WebSocket连线过程中，需要通过浏览器发出WebSocket请求，然后服务器发出回应，这个过程通常称为握手，在WebSocket API中，只需要做一次握手，实现数据传送。</p>
<h3 id="websocket与socket区别">WebSocket与Socket区别</h3>
<h4 id="websocket">WebSocket</h4>
<p>1.WebSocket建立阶段是依赖于http协议的，握手阶段是http协议，完成之后变成WebSocket协议，完全脱离socket。<br>
2.建立通讯时，是客户端主动发起请求，服务端被动监听<br>
3.建立通讯后，变成“双全工”模式，服务端和客户端都在任何时间自由发送数据，<br>
4.交互模式不再是请求应答，完全由开发者自行设计<br>
5.通信的数据是基于“帧frame”的，可以传输文本数据，也可以直接传输二进制数据，效率高，封包、拆包、编号。</p>
<h4 id="socket">socket</h4>
<p>1.服务器监听通讯，被动提供服务，每次交互都是客户端主动发起请求，服务端被动应答。<br>
2.服务端不能被动向客户端推送数据<br>
3.通讯数据基于文本格式，二进制数据（图片等）需要转换</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[丹徒]]></title>
        <id>https://spark-wz.github.io/post/dan-tu</id>
        <link href="https://spark-wz.github.io/post/dan-tu">
        </link>
        <updated>2020-07-19T02:01:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装服务器">安装服务器</h3>
<p>服务器品牌华为  delete进入bios<br>
bios初始密码 Huawei12#$<br>
root密码123qwe123QWE</p>
<h4 id="丹徒mysql">丹徒MySQL</h4>
<p><strong>MySQL更改加密规则，修改密码</strong><br>
ALTER USER 'root'@'%t' IDENTIFIED WITH mysql_native_password BY '123qweQWE@'; //修改加密规则<br>
ALTER USER 'root'@'%' IDENTIFIED BY '123@qweQWE' PASSWORD EXPIRE NEVER; //修改密码<br>
FLUSH PRIVILEGES; //刷新权限</p>
<h4 id="丹徒taos">丹徒taos</h4>
<p><strong>超级表</strong><br>
CREATE TABLE lc (ts timestamp, lc float, temp float, corrected_vol float, standard_vol float, corrected_dens float, standard_dens float, mass float, pressure float)<br>
TAGS (gkwz binary(20), oil_type binary(20));<br>
<strong>子表</strong><br>
CREATE TABLE lc3019 USING lc TAGS ('一分库', '0#柴油')<br>
<strong>写入数据</strong><br>
INSERT INTO lc3018 VALUES ('2020-07-25 00:00:00.000', 10,1,1,1,1,1,1,1);</p>
<h4 id="jar包启动">jar包启动</h4>
<p><strong>jeecg</strong><br>
nohup java -jar jeecg-boot-module-system-2.1.4.jar &gt;catalina.out 2&gt;&amp;1 &amp;<br>
<strong>shr</strong><br>
nohup java -jar sr-gasoline-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &gt;&gt; catalina.out  2&gt;&amp;1 &amp;</p>
<h4 id="页面">页面</h4>
<p>铁路收发油历史<br>
http://192.168.1.254/page/shr/#/oil-railway-history<br>
铁路实时<br>
http://192.168.1.254/page/tl/#/oil-railway-realtime<br>
铁路收发油统计<br>
http://192.168.1.254/page/shr/#/railway-transport-stat<br>
铁路流量计管理<br>
http://192.168.1.254/page/shr/#/flowmeter-mgmt<br>
水路流量计历史<br>
http://192.168.1.254/page/tl/#/oil-port-history<br>
水路实时<br>
http://192.168.1.254/page/tl/#/oil-port-realtime<br>
水路流量计管理<br>
http://192.168.1.254/page/tl/#/flowmeter-mgmt-port<br>
水路收发油统计<br>
http://192.168.1.254/page/tl/#/transport-stat-port<br>
钥匙柜历史<br>
http://192.168.1.254/page/shr/#/key-mgmt-history<br>
钥匙柜实时<br>
http://192.168.1.254/page/shr/#/key-mgmt-realtime<br>
巡更历史<br>
http://192.168.1.254/page/shr/#/patrol-history<br>
巡更实时<br>
http://192.168.1.254/page/shr/#/patrol-status<br>
汽车实时<br>
http://192.168.1.254/page/tl/#/oil-station-realtime<br>
汽车历史<br>
http://192.168.1.254/page/tl/#/oil-station-history</p>
<p>d17f014839872fcf53fa53edaee7e076.png</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nodejs循环和异步]]></title>
        <id>https://spark-wz.github.io/post/nodejs-xun-huan-he-yi-bu</id>
        <link href="https://spark-wz.github.io/post/nodejs-xun-huan-he-yi-bu">
        </link>
        <updated>2020-07-10T03:02:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="在for循环内调用异步方法">在for循环内调用异步方法</h3>
<p><img src="https://spark-wz.github.io/post-images/1594350395285.png" alt=""><br>
输出结果为<br>
undefined: AAA<br>
undefined: BBB<br>
undefined: CCC<br>
将i打印出来，结果都为3。所以fs.readFile的回调函数中访问到的i值都是循环结束后的值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[excel导出]]></title>
        <id>https://spark-wz.github.io/post/excel-dao-chu</id>
        <link href="https://spark-wz.github.io/post/excel-dao-chu">
        </link>
        <updated>2020-07-07T10:13:49.000Z</updated>
        <content type="html"><![CDATA[<p>//导出Excel，xlsx格式<br>
router.get('/exportexcel',async (ctx) =&gt; {<br>
async function readydata() {<br>
//做点什么，如从数据库取数据<br>
let exceldata=[<br>
{name:&quot;张三&quot;,age:&quot;20&quot;,sex:&quot;男&quot;,birthday:&quot;1998-10-10&quot;},<br>
{name:&quot;李四&quot;,age:&quot;21&quot;,sex:&quot;男&quot;,birthday:&quot;1997-08-08&quot;},<br>
{name:&quot;王五&quot;,age:&quot;22&quot;,sex:&quot;男&quot;,birthday:&quot;1996-06-06&quot;},<br>
{name:&quot;赵六&quot;,age:&quot;20&quot;,sex:&quot;男&quot;,birthday:&quot;1998-12-12&quot;},<br>
];<br>
return exceldata;<br>
}<br>
//导出<br>
async function exportdata(v) {<br>
let conf ={};<br>
conf.name = &quot;mysheet&quot;;//表格名<br>
let alldata = new Array();<br>
for(let i = 0;i&lt;v.length;i++){<br>
let arr = new Array();<br>
arr.push(v[i].name);<br>
arr.push(v[i].age);<br>
arr.push(v[i].sex);<br>
arr.push(v[i].birthday);<br>
alldata.push(arr);<br>
}<br>
//决定列名和类型<br>
conf.cols = [{<br>
caption:'姓名',<br>
type:'string'<br>
},{<br>
caption:'年龄',<br>
type:'number'<br>
},{<br>
caption:'性别',<br>
type:'string'<br>
},{<br>
caption:'出生日期',<br>
type:'string',<br>
//width:280<br>
}];<br>
conf.rows = alldata;//填充数据<br>
let result = nodeExcel.execute(conf);<br>
//最后3行express框架是这样写<br>
// res.setHeader('Content-Type', 'application/vnd.openxmlformats');<br>
// res.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + &quot;Report.xlsx&quot;);<br>
// res.end(result, 'binary');<br>
let data = new Buffer(result,'binary');<br>
ctx.set('Content-Type', 'application/vnd.openxmlformats');<br>
ctx.set(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + &quot;Report.xlsx&quot;);<br>
ctx.body=data;<br>
}<br>
let r=await readydata();<br>
r=await exportdata(r);<br>
});</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[参数sql]]></title>
        <id>https://spark-wz.github.io/post/can-shu-sql</id>
        <link href="https://spark-wz.github.io/post/can-shu-sql">
        </link>
        <updated>2020-07-02T02:28:01.000Z</updated>
        <content type="html"><![CDATA[<p>select count(pp)alias from test where pp='立项' or pp='签约' or pp='已完成' or pp='引入经费计划'   历年累计立项数</p>
<p>select count(pp)alias from test where pp='规划' or pp='立项' or pp='进行中' or pp='已完成' or pp='引入经费计划'  规划新上项目数</p>
<p>select count(pp)alias from test where pp='已完成' and importance = '重点项目'  实际完成重点项目数</p>
<p>select count(pp)alias from test 规划任务总量</p>
<p>select count(pp)alias from test where pp='已完成' and importance = '一般项目' 实际完成一般项目数量</p>
<p>select sum(funds_allocated)alias from test where importance = '重点项目' 以拨付重点项目经费</p>
<p>select sum(funds)alias from test  规划经费总额</p>
<p>select sum(funds_allocated)alias from test where importance = '一般项目' 以拨付一般项目经费</p>
<p>select count(id)alias from test where funds_allocated &gt; funds and importance = '重点项目'    超概算重点项目数量</p>
<p>select count(id)alias from test where funds_allocated &gt; funds and importance = '一般项目'    超概算一般项目数量</p>
<p>select sum(funds_allocated - funds)alias from test where funds_allocated &gt; funds and importance = '重点项目'    超概算重点项目金额</p>
<p>select sum(funds_allocated - funds)alias from test where funds_allocated &gt; funds and importance = '一般项目'    超概算一般项目金额</p>
<p>select count(id)alias from test where pp='立项' or pp='进行中' or pp='已完成' and importance = '重点项目' and year = ?' 年度新上重点项目已立项数</p>
<p>select count(id)alias from test where pp='立项' or pp='进行中' or pp='已完成' and importance = '一般项目' and year = ? 年度新上一般项目已立项数</p>
<p>select count(id)alias from test  year = ? 年度新上项目数<br>
select count(id)alias from test  year = ? 年度总项目数<br>
select count(id)alias from test where  pp='进行中' or pp='已完成' and importance = '重点项目' and year = ?' 年度签订重点项目合同数<br>
select count(id)alias from test where  pp='进行中' or pp='已完成' and importance = '一般项目' and year = ? 年度签订一般项目合同数<br>
select count(id)alias from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '重点项目' and year = ?' 列入经费计划的重点项目数<br>
select count(id)alias from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '一般项目' and year = ? 列入经费计划的一般项目数<br>
select sum(funds_allocated)alias  from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '重点项目' 列入经费计划的重点项目已拨付经费数<br>
select sum(funds_allocated)alias  from test where  pp='进行中' or pp='已完成' or pp='引入经费计划' and importance = '一般项目' 列入经费计划的一般项目已拨付经费数<br>
select count(importance)alias from test where importance='重点项目' and pp = '已完成'   已完成重点项目数<br>
select count(importance)alias  from test where importance='一般项目' and pp = '已完成'   已完成一般项目数<br>
select count(id)alias  from test where competition_and_selection ='是' and importance = '重点项目'  竞争择优确定的重点项目数<br>
select count(id)alias  from test where competition_and_selection ='是' and importance = '一般项目'  竞争择优确定的一般项目数<br>
select count(software_or_hardware)alias from test where software_or_hardware='软件'  软件项目总数<br>
select count(is_private)alias from test  总承研单位数量<br>
select count(is_private)alias from test where importance='重点项目' and is_private='是'   重点项目民营承研单位数量<br>
select count(is_private)alias from test where importance='一般项目' and is_private='是'   一般项目民营承研单位数量<br>
select count(domestic_sw)alias from test where importance = '重点项目'<br>
重点项目国产化软件数<br>
select count(domestic_sw)alias from test where importance = '一般项目'<br>
一般项目国产化软件数<br>
select sum(total_part)alias from test 项目零部件总数<br>
select sum(domestic_part)alias from test where importance = '重点项目'<br>
重点项目国产化零部件数<br>
select sum(domestic_part)alias from test where importance = '一般项目'<br>
一般项目国产化零部件数</p>
<p>历年评分</p>
<p>用年去限定，只查当年，一天更新一次，查询指标表，然后遍历，拿到里面的参数、权重、运算符去计算，返回 指标名、最终的计算结果、指标分数、指标权重、的json数组  （根据年限分组）</p>
<p>在nodejs里面找一个方法，只执行一次，以后不在执行<br>
执行上边方法，不用年限定</p>
<p>// //查询<br>
// function getQueryYear (parameter,year){<br>
//   return new Promise((resolve, reject) =&gt; {<br>
//     database.all(&quot;select parameter_sql from parameter where parameter_name =&quot;+&quot;'&quot;+parameter+&quot;'&quot;,function (err,row) {<br>
//       var sql = (row[0].parameter_sql);<br>
//       if(!err){<br>
//         database.all(sql+&quot;and year = &quot;+&quot;'&quot;+year+&quot;'&quot;,function (err,row) {<br>
//           console.log(sql+&quot;and year = &quot;+&quot;'&quot;+year+&quot;'&quot;)<br>
//           if (!err){<br>
//             resolve (row[0].alias);<br>
//           }else {<br>
//             console.log(err);<br>
//             return 1;<br>
//           }<br>
//         })<br>
//       }<br>
//       else{<br>
//         console.log(err);}<br>
//     });<br>
//   });<br>
// }<br>
// //score删除<br>
// function deleteScore(vals) {<br>
//   database.run(&quot;update score set is_deleted = '1' where year =&quot;+vals,function (err) {<br>
//     if(null != err){<br>
//       database.printErrorInfo(err);<br>
//     }else {<br>
//       return 1;<br>
//     };<br>
//   })<br>
// }<br>
// deleteScore(&quot;2021&quot;)</p>
]]></content>
    </entry>
</feed>