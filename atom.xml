<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://spark-wz.github.io</id>
    <title>Gridea</title>
    <updated>2020-05-08T03:14:47.435Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://spark-wz.github.io"/>
    <link rel="self" href="https://spark-wz.github.io/atom.xml"/>
    <logo>https://spark-wz.github.io/images/avatar.png</logo>
    <icon>https://spark-wz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[毕业论文]]></title>
        <id>https://spark-wz.github.io/post/bi-ye-lun-wen/</id>
        <link href="https://spark-wz.github.io/post/bi-ye-lun-wen/">
        </link>
        <updated>2020-04-24T09:04:04.000Z</updated>
        <content type="html"><![CDATA[<p>学生 查看个人信息    查看成绩   个人信息管理    选课      登录（登录通过真实邮箱验证） 注册<br>
教师   个人信息  包括管理   查看本班学生信息 成绩 登录  学生打分 Excel表导出<br>
管理员  对教师的管理，增删盖查  对选课的增删盖查</p>
<p>邮箱校验没有做</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.20上饶]]></title>
        <id>https://spark-wz.github.io/post/420-shang-rao/</id>
        <link href="https://spark-wz.github.io/post/420-shang-rao/">
        </link>
        <updated>2020-04-17T07:53:52.000Z</updated>
        <content type="html"><![CDATA[<p>本地更改油品数据字典</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序]]></title>
        <id>https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/</id>
        <link href="https://spark-wz.github.io/post/wei-xin-xiao-cheng-xu/">
        </link>
        <updated>2020-04-02T09:47:30.000Z</updated>
        <content type="html"><![CDATA[<p>第一步：前端调用wx.login()函数，获取返回的code值。（每次通过wx.login()得到的code值可能不一样）</p>
<p>第二步：传递获取到的code值到服务器端，在服务器端用小程序appid，appsecret等去请求微信服务器，获取openid和session_key。（注：每个微信账号，在每个小程序中获取到的openid是唯一的，它可以作为判断新用户和老用户的依据。）</p>
<p>第三步：将用户openid保存到数据库，并将用户id返回到前端，放到缓存中保持登录态</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python BeautifulSoup]]></title>
        <id>https://spark-wz.github.io/post/python-beautifulsoup/</id>
        <link href="https://spark-wz.github.io/post/python-beautifulsoup/">
        </link>
        <updated>2020-04-01T08:42:35.000Z</updated>
        <content type="html"><![CDATA[<p>BeautifulSoup是一个可以从html或者xml中提取数据的Python库。<br>
BeautifulSoup最常用解析器（lxml）效率最高<br>
soup = BeautifulSoup(rurl,'lxml')</p>
<p><strong>根据name属性找<br>
soup.name<br>
soup.head 只获取head标签<br>
soup.body.b 获取第一个b标签<br>
通过点取属性的方式只能获得当前名字的第一个tag标签<br>
获取所有的a标签soup.find_all()<br>
soup.find_all('a')</strong></p>
<p><strong>tag的.contains属性可以将tag的子节点以列表的方式输出<br>
字符创没有.contains属性，因为没有子节点。<br>
tag的.children可以对tag的直接子节点循环<br>
for child in title_tag.children:<br>
print(child)<br>
.descendants可以对tag的所有子孙节点进行递归循环<br>
for child in head_tag.descendants:<br>
print(child)</strong></p>
<pre><code>**.parent 可以拿到父节点
html的父节点是BeautifulSoup
.parents可以递归循环所有的父类节点
link = soup.a
</code></pre>
<p>link</p>
<h1 id="a-classsister-hrefhttpexamplecomelsie-idlink1elsiea"><a class="sister" href="http://example.com/elsie" id="link1">Elsie</a></h1>
<p>for parent in link.parents:<br>
if parent is None:<br>
print(parent)<br>
else:<br>
print(parent.name)<br>
**</p>
<p><strong>兄弟节点</strong><br>
sibling_soup.prettify())输出所有兄弟节点<br>
sibling_soup.b.next_sibling 输出后边的兄弟节点</p>
<h1 id="ctext2c"><c>text2</c></h1>
<p>sibling_soup.c.previous_sibling输出前边的兄弟节点</p>
<h1 id="btext1b"><b>text1</b></h1>
<p><strong>正则表达式</strong><br>
re<br>
import re<br>
complie()返回匹配的对象，单独使用没有意义，和find_all搭配使用</p>
<p><strong>true</strong><br>
for tag in soup.find_all(True):<br>
print(tag.name)</p>
<h1 id="html">html</h1>
<h1 id="head">head</h1>
<h1 id="title">title</h1>
<h1 id="body">body</h1>
<h1 id="p">p</h1>
<h1 id="b">b</h1>
<h1 id="p-2">p</h1>
<h1 id="a">a</h1>
<h1 id="a-2">a</h1>
<h1 id="a-3">a</h1>
<h1 id="p-可以匹配任何值但是不会返回字符串节点">p 可以匹配任何值，但是不会返回字符串节点。</h1>
<p><strong>id</strong><br>
soup.find_all(id='link2')<br>
根据id匹配</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL规范]]></title>
        <id>https://spark-wz.github.io/post/mysql-gui-fan/</id>
        <link href="https://spark-wz.github.io/post/mysql-gui-fan/">
        </link>
        <updated>2020-01-06T06:56:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>数据类型</strong><br>
MySQL中小数的数据类型有float（前7）和double（前15），都是浮点类型数都只有前几位准确，不精确，decimal是精确的小数，通常用于货币，计算精确的数。<br>
varchar类型的，如果长度不超过255都用char</p>
<p><strong>基本字段</strong><br>
一般表的基本字段，id、is_deleted(假删除)、c_t、u_t、create_user、update_user、create_user_name、update_user_name</p>
<p><strong>注意事项</strong><br>
记得写注释<br>
记得加默认值，数字的就是0<br>
字符串的就 EMPTY STRING<br>
<img src="https://spark-wz.github.io/post-images/1578298913491.png" alt="" loading="lazy"><br>
如果字符串时null的话，去查的话就很废效率。</p>
<p>前端传给我取钥匙或者存钥匙<br>
把所有状态为空的钥匙柜放在实时页面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[钥匙柜]]></title>
        <id>https://spark-wz.github.io/post/yao-chi-ju/</id>
        <link href="https://spark-wz.github.io/post/yao-chi-ju/">
        </link>
        <updated>2019-12-30T06:25:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>整体流程</strong><br>
从钥匙柜sqlserver数据库里面取数存到mysql中,再从sqlserver中读数给前端。<br>
两张表一张实时表,一张历史表<br>
<strong>要点</strong></p>
<ul>
<li>实时数据<br>
切换到MySQL,从MySQL中读数返给前端,根据时间排序。写一个同步方法，先切换到MySQL中,删除MySQL实时表中的数据,再切换到sqlserver，读取sqlserver中的数据,再切换到MySQL,插入   显示当前所有钥匙状态。<br>
历史数据<br>
同步方法中，切换到MySQL,根据时间排序查到最后一个更新的id,切换到SqlServer,按条件查询，将id大于MySQL最后一个id的记录查出(条件查询)，再切换到MySQL，查到的集合插入。</li>
</ul>
<p>写一个根据前端参数返回数据的方法，返回给前端。<br>
<strong>sqlServer的generator配置</strong><br>
<jdbcConnection driverClass="com.microsoft.sqlserver.jdbc.SQLServerDriver" connectionURL="jdbc:sqlserver://HQR333TW24G54FN\ADMIN; DatabaseName=I-KeyBox" userId="sa" password="123456"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\ggdon\sqljdbc4-4.0.jar"/><br>
<strong>MySQL的generator配置</strong><br>
<jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://39.97.227.216:3306/gasoline?useUnicode=true&amp;characterEncoding=utf8" userId="root" password="Platform@123"></jdbcConnection><br>
数据库驱动<br>
<classPathEntry  location="E:\apache-maven-3.5.0\repository\mysql\mysql-connector-java\5.1.6\mysql-connector-java-5.1.6.jar"/></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录一次本地jar包导入maven仓库踩到的坑]]></title>
        <id>https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/</id>
        <link href="https://spark-wz.github.io/post/ji-lu-yi-ci-ben-di-jar-bao-dao-ru-maven-cang-ku-cai-dao-de-keng/">
        </link>
        <updated>2019-12-20T02:27:13.000Z</updated>
        <content type="html"><![CDATA[<p>首先将conf/repository中的setttings中的配置文件路径改成自己的路径，要不会报一个路径不对的错，如下<br>
<img src="https://spark-wz.github.io/post-images/1576809073329.png" alt="" loading="lazy"><br>
改成自己的路径之后使用mvn命令直接将jar包导入自己的maven仓库，设置好依赖的3个属性。<br>
将jar包放到lib目录下<br>
mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.7.jar -DgroupId=com.wz.package -DartifactId=modbus4j -Dversion=2.0.7 -Dpackaging=jar<br>
其中Dfile是当前目录加jar包全称，DgroupId 可以随便起，DartifactId一般是jar包名,Dversion是版本号。</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/serotonin-timer-2.0.6.jar -DgroupId=com.wz.package -DartifactId=serotonin-timer -Dversion=2.0.6 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/commons-logging-1.2.jar -DgroupId=com.wz.package -DartifactId=commons-logging -Dversion=1.2 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/sqljdbc4-3.0.jar -DgroupId=com.wz.package -DartifactId=sqljdbc4 -Dversion=3.0 -Dpackaging=jar</p>
<p>mvn install:install-file -Dfile=E:\apache-maven-3.5.0\lib/modbus4j-2.0.2.jar -DgroupId=com.wz.package -DartifactId=modbus4j2 -Dversion=2.0.2 -Dpackaging=jar</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式]]></title>
        <id>https://spark-wz.github.io/post/lambda-biao-da-shi/</id>
        <link href="https://spark-wz.github.io/post/lambda-biao-da-shi/">
        </link>
        <updated>2019-12-18T01:38:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简介</strong><br>
Lambda表达式是一个匿名函数，简单来说就是一种没有声明的方法，即没有访问修饰符，返回值声明和名称。<br>
在仅编写一次方法的地方特别有用，方法定义很短，他为我们节省了，包含类声明和编写单独方法的工作。<br>
Java中的Lambda表达式通常使用语法是(argument) -&gt; (body)</p>
<p>以下是Lambda表达式的一些实例</p>
<p>(int a, int b) -&gt; { return a + b;}<br>
() -&gt; System.out.println(&quot;Hello World&quot;);<br>
(String s) -&gt; {System.out.println(s);}<br>
() -&gt; 42<br>
() -&gt; { return 3.1415};</p>
<p>**Lambda 表达式的结构</p>
<p>Lambda 表达式可以具有零个，一个或多个参数。<br>
可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如 (int a) 与刚才相同 (a)。<br>
参数用小括号括起来，用逗号分隔。例如 (a, b) 或 (int a, int b) 或 (String a, int b, float c)。<br>
空括号用于表示一组空的参数。例如 () -&gt; 42。<br>
当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 a -&gt; return a*a。<br>
Lambda 表达式的正文可以包含零条，一条或多条语句。<br>
如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。<br>
如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。</p>
<p><strong>4.2 使用方式</strong><br>
双冒号(::)操作符是java的方法引用。当我们使用一个方法的引用时，目标引用放在冒号前，目标引用提供的方法在：：之后。即目标引用::方法。<br>
person::getAge;<br>
在person类中定义的方法getAge的引用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BIO,NIO,AIO总结]]></title>
        <id>https://spark-wz.github.io/post/bionioaio-zong-jie/</id>
        <link href="https://spark-wz.github.io/post/bionioaio-zong-jie/">
        </link>
        <updated>2019-12-11T08:08:47.000Z</updated>
        <content type="html"><![CDATA[<p>目录:</p>
<ol>
<li>BIO (Blocking I/O) 同步并阻塞<br>
1.1 传统 BIO<br>
1.2 伪异步 IO<br>
1.3 代码示例<br>
1.4 总结</li>
<li>NIO (New I/O)    同步非阻塞<br>
2.1 NIO 简介<br>
2.2 NIO的特性/NIO与IO区别<br>
1)Non-blocking IO（非阻塞IO）<br>
2)Buffer(缓冲区)<br>
3)Channel (通道)<br>
4)Selectors(选择器)<br>
2.3 NIO 读数据和写数据方式<br>
2.4 NIO核心组件简单介绍<br>
2.5 代码示例</li>
<li>AIO (Asynchronous I/O)   异步非阻塞</li>
</ol>
<p><strong>实例</strong><br>
<strong>1. BIO (Blocking I/O)</strong><br>
同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程中等待其完成。<br>
<strong>1.1传统BIO通信模型</strong><br>
通常用一个独立的Acceptor负责监听客户端的连接，一般会在While(true)循环服务中调用accept()方法等待接受客户端请求的连接的方式监听请求，一旦接到请求，就可以在这之上进行读写请求，此时不能再接受其他客户端连接请求。只能等待当前连接的操作完成，但是可以通过多线程来支持多个客户端的连接。</p>
<p>如果想让BIO通信模型能够同时处理多个请求，就必须使用多线程（主要原因是socket.accept(),socket.read(),socket.write()射击的三个方法都是同步阻塞的），也就是说他接到客户端连接请求之后为客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答模型</strong>，如果连接创建之后不做任何事情的话，就会造成不必要的线程开销，但是可以通过 <strong>线程池</strong> 来改善，线程池还可以让线程的创建和回收成本更低。使用了FixedThreadPool可以有效的控制线程的最大数量，保证了系统有限的资源控制，实现了N（客户端请求数量）:M（处理客户端请求的线程数量）的伪异步I/O模型。</p>
<p><strong>当客户端并发访问量增加后</strong><br>
可能会导致线程堆栈溢出，创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p>
<p><strong>1.2 伪异步 IO</strong><br>
<strong>1.3代码示例</strong><br>
客户端</p>
<figure data-type="image" tabindex="1"><img src="https://spark-wz.github.io/post-images/1576489092714.png" alt="" loading="lazy"></figure>
<pre><code>服务端

serverSocket.accept() 接收客户端的连接请求，返回一个套接字，如果没有连接到客户端，线程处于阻塞状态，程序无法执行下去。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://spark-wz.github.io/post-images/1576489522129.png" alt="" loading="lazy"></figure>
<p><strong>1.4小结</strong></p>
<p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p><strong>NIO new (I/O)</strong><br>
同步非阻塞的I/O模型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合常用]]></title>
        <id>https://spark-wz.github.io/post/java/</id>
        <link href="https://spark-wz.github.io/post/java/">
        </link>
        <updated>2019-12-11T07:14:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>java中将数组转为list</strong><br>
String[] myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List<String> myList = Arrays.asList(myArray);<br>
但是这个方法将数组转为集合后，集合的底层还是数组<img src="https://spark-wz.github.io/post-images/1576048771521.jpg" alt="" loading="lazy"><br>
2.传递的对象必须是基本对象，不能是包装类<br>
int[] myArray = { 1, 2, 3 };<br>
List myList = Arrays.asList(myArray);<br>
System.out.println(myList.size());//1<br>
System.out.println(myList.get(0));//数组地址值<br>
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException<br>
当传入原生数据类型是,myList.get(0)拿到的是数组本身，而不是第一个值<br>
List myList = Arrays.asList(1, 2, 3);<br>
myList.add(4);//运行时报错：UnsupportedOperationException<br>
myList.remove(1);//运行时报错：UnsupportedOperationException<br>
myList.clear();//运行时报错：UnsupportedOperationException<br>
在使用add(),remove(),clear()会报错<br>
<em>正确的最简便的方法</em><br>
String myArray = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;};<br>
List list = new ArrayList&lt;&gt;(Arrays.asList(myArray));</p>
<p><strong>遍历Map</strong></p>
<p>1.通过map.keySet()</p>
<p>通过key去获取value<br>
Set<Integer> set = map.keySet();</p>
<p>for (Integer integer: set) {</p>
<p>System.out.println(integer +&quot;的对应值为:&quot; + map.get(integer));</p>
<p>}<br>
2.通过map.values遍历所有的value</p>
<p>Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();<br>
map.put(1,1);<br>
map.put(2,2);<br>
map.put(3,3);<br>
Collection<Integer> values = map.values();<br>
for (Integer value : values) {<br>
System.out.println(&quot;value = &quot; + value);<br>
}<br>
3.遍历map.entrySet</p>
<p>遍历map.entrySet,可同时拿到所有的KEY和VALUE<br>
Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();<br>
for (Map.Entry&lt;Integer, Integer&gt; entry : entries) {<br>
System.out.println(&quot;entry.getValue() = &quot; + entry.getValue());<br>
}</p>
<p>4.lambda表达式</p>
<p>map.forEach((key,value) -&gt;{<br>
System.out.println(&quot;key = &quot; + key+&quot;value = &quot;+value);<br>
});</p>
]]></content>
    </entry>
</feed>